[
  {
    "objectID": "lectures/lec02.html",
    "href": "lectures/lec02.html",
    "title": "Lecture 2: Assembly Language Fundamentals",
    "section": "",
    "text": "Let us consider the following program:\n;\n;   Adding two numbers\n;\n      global _main\n      \n      section .data\nsum   dd      0\n\n      section .code\n_main:\n      mov     eax, 5      ; let eax = 5\n      add     eax, 6      ; add 6 to eax\n      mov     [sum], eax  ; store result into sum\n      \n      ret\n\n\n\nAssembly program consists of statements. There are three types of statements: instructions, directives, and macros.\nAn instruction is translated by the assembler into one or more bytes of object code (machine code), which will be executed at run time.\nA directive tells the assembler to perform some special tasks, such as allocating memory space for a variable or creating a procedure.\nA macro is “shorthand” for a sequence of other statements.\nBy default, assembly is not case-sensitive.\nAny statement has up to four fields, separated by at least one white space:\n[label:]     instruction   [operand(s)]   [;comment]\n\nThe four fields are displayed in the following diagram:\n\n\n\nThe layout of source lines. Blue rectangle for label; Red rectangle for either instruction or directive; Orange rectangle for operands or arguments; Green rectangle for comment\n\n\n\n\n\n\nA comment always starts with a semicolon character ; and ends with newline character, as shown as red rectangles in the following diagram:\n\nAt the top of every program, you should add a comment block that contains:\n\nThe name of the source code file,\nThe date you created the file,\nThe date you last modified the file,\nThe name of the person who wrote it,\nThe name and version of the assembler used,\nAn overview description of the what the program or library does.\nA copy of the commands used to build the file\nHere is an example:\n; -----------------------------------------------------------------\n; Source name   : addtwo.asm\n; Version       : 1.0\n; Created date  : 10/4/2020\n; Last modified : 22/8/2024\n; Author        : Khalid Elbadawi\n; Compiling     : nasm -fwin32 addtwo.asm (NASM version 2.15)\n; Description   : Store the result of 5 + 6 \n; -----------------------------------------------------------------\n\n\n\n\n\n\nGenerally, programs written in assembly language are divided into sections, which represent memory segments.\nSections are defined by the assembler directive.\nIn NASM, sections are created by using section keyword followed by the section name, such as .data, .bss, or .text\n\nThe .data section: contains data definitions of initialized data items\nThe .bss section: contains data definitions of uninitialized data items\nThe .text section: contains the actual machines instructions (i.e., the code) that make up your program\n\nIn the following diagram, the data section is enclosed by the GREEN rectangle and code (or text) section is enclosed by the RED rectangle:\n\n\n\n\n\n\nA label field is a programmer-chosen identifier. It might identify a variable, a constant, a procedure or an instruction label.\nRules for choosing an identifier are (in NASM):\n\nMust not exceed more than 247 characters\nMust start with a letter, underscore or ?.\nSubsequent characters may also be digits, @, #, $, or dot.\nMust not be a reserved word\n\nIn general, it’s good idea to use descriptive names for identifiers.\nLabels, in NASM, are case sensitive.\n\n\n\n\n\nThere are different types of reserved words:\n\nInstruction mnemonics (the Instruction Set), such as ADD, SUB, MOV.\nRegister names, such as EAX, AX, AL, ch\nDirectives, such as DB, DWORD.\nOperand attributes, such FAR, NEAR, BYTE.\nOperators used in constant expressions.\n\nReserved words are NOT case sensitives\n\n\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\n\n[{+|-}] digits [radix]\n\n\nwhere radix can be\n\nh (hexadecimal),\no or q (octal),\nd (decimal), and\nb (binary)\n\n\n\n\n\n\n\nExample\n\n\n\n\n\n\nInteger constants\nBase\n\n\n\n\n198\ndecimal\n\n\n0200\ndecimal\n\n\n-2d\ndecimal\n\n\n+101b\nbinary\n\n\n1100_0001b\nbinary\n\n\n107o\noctal\n\n\n107q\nstill octal (more readable)\n\n\n23bh\nhexadecimal\n\n\n23Bh\nhexadecimal\n\n\n0ah\nhexadecimal\n\n\n0xC8\nhexadecimal (C syntax)\n\n\n\n\n\n\n\n\n\nCharacters and character string must be enclosed in single quotes, double quotes or back quotes.\n\n\"A\" or \"Hello\"\n'A' or 'Hello'\n`A` or `Hello`\n\nCharacters are stored in contiguous memory and translated into their ASCII codes by the assemblers, so there is no difference between using \"A\" and 41h in an assembly program.\n\n\n\nCharacter/String Literal\nValue in Hex\n\n\n\n\n'm'\n6Dh\n\n\n\"School\"\n53h, 63h, 68h, 6Fh, 6Fh, 5Ch\n\n\n\"Joe\"\n4Ah, 6Fh, 65h\n\n\n\"A Bank.\"\n41h, 30h, 42h, 61h, 6Eh, 6Bh, 2Eh\n\n\n\"Joe's\"\n4Ah, 6Fh, 65h, 27h, 73h\n\n\n\n\n\n\n\n\n\nAn instruction consists of an instruction mnemonic followed by zero, one, two, or three operands.\nAn instruction mnemonic is a short word that identifies an instruction, such as mov, add, and sub.\nAn instruction operand can be used for input or output for the instruction. For example, consider the following instruction:\nadd   eax, [x]    ; x is a label for memory location (variable) \n\nadd is the instruction mnemonic\neax is the first operand. This operand acts as an input and output\n[x] is the second operand. This operand acts as an input.\nThe semantic of this instruction is as follows. Add the content of x to eax and store the result into eax (i.e., eax = eax + [x])\nThere is a natural ordering of operands. When instructions have multiple operands, the first one is typically called the destination operand. The second operand is usually called the source operand.\n\nInstruction operand can be:\n\nExplicit, in which the operand appears in the instruction statement (see the example above)\nImplicit, in which the operand does not appear in the statement. For example, consider the following integer multiplication instruction:\n      imul    ebx\nThe operand ebx represents the multiplier. The multiplicand is the register EAX and the product is stored in two registers: EDX and EAX. We are going to explain this instruction in much detail in future lectures.\n\nGenerally, the instructions we are going to study in this course fall under general–purpose Instructions, which perform basic data movement, arithmetic, logic, program flow, and string operations that programmer commonly use to write application and system software. In this course we are going to focus on:\n\nData movement/transfer instructions,\nArithmetic and Logic instructions,\nControl transfer instructions, and\nFlag control instructions"
  },
  {
    "objectID": "lectures/lec02.html#an-assembly-program",
    "href": "lectures/lec02.html#an-assembly-program",
    "title": "Lecture 2: Assembly Language Fundamentals",
    "section": "",
    "text": "Let us consider the following program:\n;\n;   Adding two numbers\n;\n      global _main\n      \n      section .data\nsum   dd      0\n\n      section .code\n_main:\n      mov     eax, 5      ; let eax = 5\n      add     eax, 6      ; add 6 to eax\n      mov     [sum], eax  ; store result into sum\n      \n      ret\n\n\n\nAssembly program consists of statements. There are three types of statements: instructions, directives, and macros.\nAn instruction is translated by the assembler into one or more bytes of object code (machine code), which will be executed at run time.\nA directive tells the assembler to perform some special tasks, such as allocating memory space for a variable or creating a procedure.\nA macro is “shorthand” for a sequence of other statements.\nBy default, assembly is not case-sensitive.\nAny statement has up to four fields, separated by at least one white space:\n[label:]     instruction   [operand(s)]   [;comment]\n\nThe four fields are displayed in the following diagram:\n\n\n\nThe layout of source lines. Blue rectangle for label; Red rectangle for either instruction or directive; Orange rectangle for operands or arguments; Green rectangle for comment\n\n\n\n\n\n\nA comment always starts with a semicolon character ; and ends with newline character, as shown as red rectangles in the following diagram:\n\nAt the top of every program, you should add a comment block that contains:\n\nThe name of the source code file,\nThe date you created the file,\nThe date you last modified the file,\nThe name of the person who wrote it,\nThe name and version of the assembler used,\nAn overview description of the what the program or library does.\nA copy of the commands used to build the file\nHere is an example:\n; -----------------------------------------------------------------\n; Source name   : addtwo.asm\n; Version       : 1.0\n; Created date  : 10/4/2020\n; Last modified : 22/8/2024\n; Author        : Khalid Elbadawi\n; Compiling     : nasm -fwin32 addtwo.asm (NASM version 2.15)\n; Description   : Store the result of 5 + 6 \n; -----------------------------------------------------------------\n\n\n\n\n\n\nGenerally, programs written in assembly language are divided into sections, which represent memory segments.\nSections are defined by the assembler directive.\nIn NASM, sections are created by using section keyword followed by the section name, such as .data, .bss, or .text\n\nThe .data section: contains data definitions of initialized data items\nThe .bss section: contains data definitions of uninitialized data items\nThe .text section: contains the actual machines instructions (i.e., the code) that make up your program\n\nIn the following diagram, the data section is enclosed by the GREEN rectangle and code (or text) section is enclosed by the RED rectangle:\n\n\n\n\n\n\nA label field is a programmer-chosen identifier. It might identify a variable, a constant, a procedure or an instruction label.\nRules for choosing an identifier are (in NASM):\n\nMust not exceed more than 247 characters\nMust start with a letter, underscore or ?.\nSubsequent characters may also be digits, @, #, $, or dot.\nMust not be a reserved word\n\nIn general, it’s good idea to use descriptive names for identifiers.\nLabels, in NASM, are case sensitive.\n\n\n\n\n\nThere are different types of reserved words:\n\nInstruction mnemonics (the Instruction Set), such as ADD, SUB, MOV.\nRegister names, such as EAX, AX, AL, ch\nDirectives, such as DB, DWORD.\nOperand attributes, such FAR, NEAR, BYTE.\nOperators used in constant expressions.\n\nReserved words are NOT case sensitives\n\n\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\n\n[{+|-}] digits [radix]\n\n\nwhere radix can be\n\nh (hexadecimal),\no or q (octal),\nd (decimal), and\nb (binary)\n\n\n\n\n\n\n\nExample\n\n\n\n\n\n\nInteger constants\nBase\n\n\n\n\n198\ndecimal\n\n\n0200\ndecimal\n\n\n-2d\ndecimal\n\n\n+101b\nbinary\n\n\n1100_0001b\nbinary\n\n\n107o\noctal\n\n\n107q\nstill octal (more readable)\n\n\n23bh\nhexadecimal\n\n\n23Bh\nhexadecimal\n\n\n0ah\nhexadecimal\n\n\n0xC8\nhexadecimal (C syntax)\n\n\n\n\n\n\n\n\n\nCharacters and character string must be enclosed in single quotes, double quotes or back quotes.\n\n\"A\" or \"Hello\"\n'A' or 'Hello'\n`A` or `Hello`\n\nCharacters are stored in contiguous memory and translated into their ASCII codes by the assemblers, so there is no difference between using \"A\" and 41h in an assembly program.\n\n\n\nCharacter/String Literal\nValue in Hex\n\n\n\n\n'm'\n6Dh\n\n\n\"School\"\n53h, 63h, 68h, 6Fh, 6Fh, 5Ch\n\n\n\"Joe\"\n4Ah, 6Fh, 65h\n\n\n\"A Bank.\"\n41h, 30h, 42h, 61h, 6Eh, 6Bh, 2Eh\n\n\n\"Joe's\"\n4Ah, 6Fh, 65h, 27h, 73h\n\n\n\n\n\n\n\n\n\nAn instruction consists of an instruction mnemonic followed by zero, one, two, or three operands.\nAn instruction mnemonic is a short word that identifies an instruction, such as mov, add, and sub.\nAn instruction operand can be used for input or output for the instruction. For example, consider the following instruction:\nadd   eax, [x]    ; x is a label for memory location (variable) \n\nadd is the instruction mnemonic\neax is the first operand. This operand acts as an input and output\n[x] is the second operand. This operand acts as an input.\nThe semantic of this instruction is as follows. Add the content of x to eax and store the result into eax (i.e., eax = eax + [x])\nThere is a natural ordering of operands. When instructions have multiple operands, the first one is typically called the destination operand. The second operand is usually called the source operand.\n\nInstruction operand can be:\n\nExplicit, in which the operand appears in the instruction statement (see the example above)\nImplicit, in which the operand does not appear in the statement. For example, consider the following integer multiplication instruction:\n      imul    ebx\nThe operand ebx represents the multiplier. The multiplicand is the register EAX and the product is stored in two registers: EDX and EAX. We are going to explain this instruction in much detail in future lectures.\n\nGenerally, the instructions we are going to study in this course fall under general–purpose Instructions, which perform basic data movement, arithmetic, logic, program flow, and string operations that programmer commonly use to write application and system software. In this course we are going to focus on:\n\nData movement/transfer instructions,\nArithmetic and Logic instructions,\nControl transfer instructions, and\nFlag control instructions"
  },
  {
    "objectID": "lectures/lec02.html#defining-data",
    "href": "lectures/lec02.html#defining-data",
    "title": "Lecture 2: Assembly Language Fundamentals",
    "section": "Defining Data",
    "text": "Defining Data\n\nIntrinsic Data Types\nIn assembly language, data types are expressed in terms of their sizes (byte, word, doubleword, etc).\n\n\n\nSize\nType\nNote\n\n\n\n\nByte\nBYTE or HWORD\n8 bits\n\n\nWord (two-byte)\nWORD\n16 bits\n\n\nDouble word (2-word)\nDWORD\n32 bits\n\n\nQuad word (4-word)\nQWORD\n64 bits\n\n\nTen-Byte (5-word)\nTBYTE or TWORD\n80 bits\n\n\nDouble-quad word (8-word)\nOWORD or DQWORD\n128 bits\n\n\nQuad-quad word (16-word)\nYWORD\n256 bits\n\n\n32-Word\nZWORD\n512 bits\n\n\n\n\n\nDefining Initialized Data (using Dx)\n\nA data definition with initialization sets aside storage in memory (in data segment) for a variable, with an optional label. The syntax:\n\n\n\n\n\n\nSyntax\n\n\n\n[name:]      directive       initializer [, initializer]\n\n\nname is an identifier to label the allocated memory. The label is always attached to the first memory location.\ndirective is a pseudo-instruction (not real x86 instruction and are used in the instruction field) that can be:\n\nData Definition in the form of Dx\n\n\nDirective\nDescription\n\n\n\n\nDB\nDefine (i.e., Allocate) BYTE\n\n\nDW\nDefine WORD\n\n\nDD\nDefine DWORD\n\n\nDQ\nDefine QWORD\n\n\nDT\nDefine TBYTE\n\n\nDO\nDefine OWORD\n\n\nDY\nDefine YWORD\n\n\nDZ\nDefine ZWORD\n\n\n\nInitializer is used to initialize the allocated memory. Additional initializers, if any, are separated by commas.\nExample\n\n\n\n\n\n\nExamples of Data Definition\n\n\n\nletter:   db    'A'   ; value is 41h\nresp      db    'Y'   ; default user response\nnum1:     db    -91   ; value is A5h\nnum2      dw    -1    ; value is FFFFh\nsum:      dd    0     ; value is 0h\n\n\n\n\nLittle Endian vs. Big Endian\nConsider the following definition\nnum:     dw    1234h\n\nAll x86 microprocessors are byte addressable. This means that each memory address can store only a single byte.\nTherefore, in the above definition, the assembler will allocate two bytes for num. But, the question that may arise: how a CPU can store the initial value into 2-byte memory?\nThere are two ways to store 1234h in memory:\n\nLittle Endian, in which the least significant byte is stored at the smallest memory address\nBig Endian, in which the most significant byte is stored at the smallest memory address.\nThe following diagram illustrates the difference:\n\nx86 microprocessors follow Little Endianness.\n\n\n\n\nMultiple Initializers\n\nThe pseudo-instruction Dx can take multiple initializers.\nIf multiple initializers are used, the memory space is allocated large enough to hold these values.\nRemember, the label is always attached to the first memory location (i.e., first byte).\nExamples: In the comments, the first byte is located at the smallest memory address.\n    db    55h, 56h, 57h   ; 0x55 0x56 0x57\n    db    'a', 55h        ; 0x61 0x55\n    db    'ab', 13, 10, 0 ; 0x61 0x62 0x0D 0x0A 0x00\n    dw    1234h, 5678h    ; 0x34 0x12 0x78 0x56\n    dw    12h, 34h        ; 0x12 0x00 0x34 0x00\n    dw    'ab'            ; 0x61 0x62\n    dw    'abc'           ; 0x61 0x62 0x63 0x00\n    dd    0x12345678      ; 0x78 0x56 0x34 0x12\n   ;db    300             ; invalid \nIn data definitions, the labels are optional and pseudo-instructions are executed by the assembler in sequential. Therefore, the following definition:\nlist    db    10, 20, 30\ncan be written as\nlist    db    10\n        db    20\n        db    30\n\n\n\nDUP Operator\n\nThe syntax of DUP operator:\n\n\n\n\n\n\nSyntax\n\n\n\n[name]    Dx   &lt;counter&gt; DUP (initializer-list)\n\n\nThe DUP operator duplicates the initializer-list specified number of times\ncounter is an constant 32-bit integer expression.\nDUP operator is useful when allocating space for an array.\nExamples:\n    db  3 dup(0)      ; db  0, 0, 0, 0, 0\n    dw  8 dup(1)      ; dw  1, 1, 1, 1, 1, 1, 1, 1\n    db  4 dup('ABC')  ; db  'ABC', 'ABC', 'ABC', 'ABC' \n\n\n\n\nDefining Uninitialized Data (using RESx)\n\nThe RESx directive is quite similar to the Dx directive, but always specifices the number of elements.\nThe RESx directive defines uninitialized storage space inside the BSS segment.\nThe syntax:\n\n\n\n\n\n\nSyntax\n\n\n\n[name:]      RESx       &lt;counter&gt;\n\n\n\ncounter is the number of x to be reserved. It must be a constant expression.\n\nExamples:\nbuffer:   resb    64    ; reserve 64 bytes\nlist:     resd    100   ; reserve 100 32-bit integers\n\n\n\nDefining Constants\n\nNASM provides a directive, named EQU, to define a symbolic constant.\nThe syntax is\n\n\n\n\n\n\nSyntax\n\n\n\nname    EQU   &lt;expression&gt;\n\n\nExamples:\nESC_KEY   equ   27\nCOUNT     equ   100\nIn the code section:\n          mov   eax, COUNT    ; good style\n          mov   eax, 100      ; bad style\n\n          mov   al, ESC_KEY   ; good style\n          mov   al, 27        ; bad style\n\n\n\nConstant Integer Expression\n\nNASM assembler (and also MASM) supports what is called constant integer expression that must evaluate to a 32-bit integer.\n\n\nAssembler Operators\n\n\n\n\n\n\n\nOperator\nName\nPrecedence\n\n\n\n\n()\nParantheses\n1\n\n\n+, -, ~, !\nUnary plus, negative, negation, logical not\n2\n\n\n*, /, //, %, %%\nmultiplication, unsigned division, signed division, unsigned modulus, signed modulus\n3\n\n\n+, -\nAddition and subtraction\n4\n\n\n&lt;&lt;, &gt;&gt;\nShift to left or right (always unsigned)\n5\n\n\n&\nBitwise AND\n6\n\n\n^\nBitwise XOR\n7\n\n\n|\nBitwise OR\n8\n\n\n\n\nConstant Integer Expression will always be evaluated by the assembler.\n\n\nThe Current Location ($) and Section Location ($$)\n\nOne of the most important symbols of all, shown as $, is called the current location.\nThe assembler handles the current location and section location expressions as follows\n\nWhen the assembler first encounters a section/segment statement, the current location counter ($) and the section location ($$) are set to the beginning of the current section.\nWhen encountering instructions or pseudo-instructions (such as Dx or RESx), the assembler increments the location counter for each byte written to the object file (i.e, after generating the object code). So, you can tell how far into the section you are by using ($ - $$).\n\nIn the following code, the current location expression is used to calculate the string length. The calculation is performed by the assembler.\nmyStr:    db    \"This is a long string, containing\"\n          db    \"any number of characters.\"\nSTRLEN    equ   ($ - myStr)"
  },
  {
    "objectID": "lectures/lec02.html#addressing-modes",
    "href": "lectures/lec02.html#addressing-modes",
    "title": "Lecture 2: Assembly Language Fundamentals",
    "section": "Addressing Modes",
    "text": "Addressing Modes\n\nWe mentioned that a CPU instruction can have zero, one, two, or three operands.\nFor exmaple:\n        add   eax, 5\nThe instruction add takes two operands. The first operand is a CPU register, and the second operand is a constant integer.\nIn assembly language, the way an operand is specified is known as addressing mode.\nGenerally, the addressing modes used by Intel architectures are:\n\nImmediate addressing mode: when an operand is a constant expression\nRegister addressing mode: when an operand is a CPU register\nMemory addressing modes, in which we have\n\nDirect memory addressing mode: when an operand is constant reference to memory location.\nIndirect memory addressing modes: when an operand is reference to memory location and this reference is determined during the running-time.\n\n\n\nThe following table is taken from Intel manuals that describes the standard operand types:\n\nInstruction Operand Notation, 32-bit Mode.\n\n\n\n\n\n\nOperand\nDescription\n\n\n\n\nreg\nAny general-purpose register\n\n\nreg8\n8-bit general-purpose register: AH, AL, BH, BL, CH, CL, DH, DL\n\n\nreg16\n16-bit general-purpose register: AX, BX, CX, DX, SI, DI, SP, BP\n\n\nreg32\n32-bit general-purpose register: EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP\n\n\nsreg\n16-bit segment register: CS, DS, SS, ES, FS, GS\n\n\nimm\n8-, 16-, or 32-bit immediate value\n\n\nimm8\n8-bit immediate byte value\n\n\nimm16\n16-bit immediate word value\n\n\nimm32\n32-bit immediate doubleword value\n\n\nmem\nAn 8-, 16-, or 32-bit memory operand\n\n\nreg/mem8\n8-bit operand, which can be an 8-bit general register or memory byte\n\n\nreg/mem16\n16-bit operand, which can be an 16-bit general register or memory word\n\n\nreg/mem32\n32-bit operand, which can be an 32-bit general register or memory doubleword\n\n\n\n\n\n\nDirect Memory Addressing Mode\n\nA direct memory operand is an operand identifier that refers to a specific offset within the data segment.\nThe offset address must be specified inside square brackets [].\n        section .bss\nsum:    resd      1\n\n        section .text\n_main:\n        mov     eax, 5\n        add     eax, 6\n        mov     [sum], eax\n\n\n\nAddressing mode and Machine Instruction\nExamine the following instruction statements. Assume the variable x is already defined.\n        mov eax, 123h       ; B8 23010000\n    \n          mov   ebx, 123h       ; BB 23010000\n    \n          mov   eax, ebx          ; 8BC3\n    \n          mov   ebx, eax          ; 8BD8\n    \n          mov   WORD [x], 123h  ; C705  00000000  23010000\n    \n          mov   [x], eax          ; A3 00000000\n    \n          mov   ah, 4             ; B4 04\n    \n          mov   al, 13            ; B0 0D   \nIf you read the object file using Hexdump tool, we will get:"
  },
  {
    "objectID": "lectures/lec02.html#data-transfer-instructions",
    "href": "lectures/lec02.html#data-transfer-instructions",
    "title": "Lecture 2: Assembly Language Fundamentals",
    "section": "Data Transfer Instructions",
    "text": "Data Transfer Instructions\n\nData transfer instructions are\n\nMOV, XCHG, MOVSX, MOVZX : to move (as copy) data from source operand to destination operand.\nPUSH, POP, PUSHA, POPA, PUSHAD, POPAD: to move data between an operand and run-time stack.\nCBW, CWD, CDQ, CWDE : to sign-extend an operand\n\nIn this lecture, we will cover MOV, XCHG, MOVSX, and MOVZX . The remaining instructions will be covered in future lectures.\n\n\nMOV Instruction\n\n\n\n\n\n\nSyntax\n\n\n\n        mov   &lt;destination&gt;, &lt;source&gt;\n\n\nThe destination operand’s content changes, but the source operand is unchanged. Right to Left data transfer is similar to the assignment statement in C++ or Java:\n    destination = source;\n\n\n\n\n\n\nRules\n\n\n\n\nBoth operands must be of the same size.\nBoth operands cannot be memory operands.\nThe instruction pointer (IP, EIP, RIP) cannot be a destination operand.\n\n\n\nAccordingly, here is a list of valid MOV instruction formats:\n    mov   reg, reg\n    mov   reg, mem\n    mov   reg, imm\n    mov   mem, reg\n    mov   mem, imm    ; you must specify the size (see next warning)\n\n\n\n\n\n\nNASM, by its design, does not store the type of variables you declared.\nFor example:\nvar     dw    4     ; var is 16-bit variable\nThe following lines are all valid:\n        mov   eax, [var]  ; transfer 4 bytes starting from offset var\n        mov   ax, [var]   ; transfer 2 bytes starting from offset var\n        mov   ah, [var]   ; transfer 1 byte from offset var\n\n\n\n\nExample\n;\n;  adding three numbers\n;\n\n        section .data\narr     dd      4, 28, 35\n\n        section .text\n_main:\n        mov   eax, [arr]      ; move the value 4 to eax\n        add   eax, [arr + 4]  ; add the value 28 to eax\n        add   eax, [arr + 8]  ; add the value 35 to eax\n\n\n\n\n\n\nInvalid MOV statements\n\n\n\n        mov   4, eax      ; dest cannot be imm\n        mov   [x], [y]    ; both operands cannot be memory\n        mov   x, eax      ; dest cannot be imm\n        mov   [x], 10     ; unknown data types (or size)\n\n\n\n\nMemory to Memory\n\n\n\n\n\n\nA single MOV instruction cannot be used to move data directly from one memory location to another.\n; assign x to y (i.e., y = x)\n        mov     eax, [x]\n        mov     [y], eax\n\n\n\n\n\n\n\n\nImmediate to Memory\nIn assembly language, the size of integer literals can be 8, 16, or 32 bits. Therefore, in the following instruction:\n      mov   ax, 5\nthe size of the source operand is unknown. However, the assembler can infer the size of immediate operand by the size of other operand (ax). Thus, the assembler translates the source operand as imm16.\nThe problem arises when the size of the other operand is also unknown; typically when we move data from imm to mem. In this case, you must tell the assembler the amount of bytes to be transferred from the source to destination by specifying the data type of at least one operand (see Intrinsic Data Types).\n\n\n\n\n\n\nExample\n\n\n\n        mov   DWORD [x], 5\n\n\nHere, the size of the first operand is doubleword. The size of the second operand will be inferred from the first one.\n\n\n\nMOVSX Instruction\n\nCan we transfer data from a smaller size to a larger size?\nThe answer is: Yes. But, you must be cautious. Consider the following example; let us assume that we need to transfer data from mem16 to reg32 (ECX).\n      section .data\nv1    dw      -16       ; FFF0h\nv2    dw      16        ; 0010h\n\n      section .text\n\n      mov     ecx, [v1] ; WRONG. ecx=0010 FFF0h\n\n      mov     ecx, 0    ; 0000 0000h\n      mov     cx, [v1]  ; 0000 FFF0h\n\n      mov     ecx, 0FFFFFFFFh\n      mov     cx, [v2]; FFFF 0010h\nMOVSX instruction (move with sign-extension) copies the content of a source operand into a destination operand with sign-extends to 16 or 32 bits.\nThis instruction is only used with signed integers and there are three variants:\n      movsx     reg32, reg/mem8\n      movsx     reg32, reg/mem16\n      movsx     reg16, reg/mem8\nThe following code corrects the above code:\n      movsx     ecx, WORD [v1]  ; ecx = FFFF FFF0h = -16\n\n      movsx     edx, WORD [v2]  ; edx = 0000 0010h = 16\n\n\n\nMOVZX Instruction\n\nMOVZX is similar to MOVSX, but with zero-extend. It is only used with unsigned integers\n\n\n\nXCHG Instruction\n\n\n\n\n\n\nSyntax\n\n\n\n        XCHG    &lt;operand1&gt; , &lt;operand2&gt;\n\n\nThe XCHG (exchange data) instruction exchanges the contents of two operands.\n\n\n\n\n\n\nRules\n\n\n\n\nBoth operands must be of the same size.\nBoth operands cannot be memory operands.\nImmediate operands are not allowed.\nThe instruction pointer (IP, EIP, RIP) cannot be a destination operand.\n\n\n\nAccordingly, this instruction has three formats:\n        XCHG    reg, reg\n        XCHG    reg, mem\n        XCHG    mem, reg\nExample: What is the value of AX and BX after executing the following code:\n        mov     ax, 0A100h\n        mov     bx, 0005h\n        xchg    ah, bl"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "C404: Assembly Language",
    "section": "",
    "text": "Course summary\nThis course covers the organization and behavior of real computer systems at the assembly-language level. Topics include the mapping of statements and constructs in a high-level language onto sequences of machine instructions, as well as the internal representation of simple data types and structures. Numerical computation and subroutines are examined.\n\n\nCourse Goals\nYou will gain the following knowledge in topics related to assembly language:\n\nIntel and AMD processor architecture and programming.\nDescribe von Neumann architecture and how its components interact.\nReal-address mode and protected mode programming.\nAssembly language directives, macros, operators, and program structure.\nDemonstrate how fundamental high-level programming constructs are implemented at the machine-language level.\nUnderstand the Assembly Language’s procedures, parameter passing and stack operations.\nProgramming methodology, showing how to use assembly language to create system-level software tools and application programs.\nDiagnosing and debuggin assembly language programs.\n\n\n\nTextbooks\n\n\n\n\n\n\nAssembly Language for x86\n\n\n\n\n\nAssembly Language for x86 Processors\nby Kip Irvine\nPearson 2019, 8th Edition\n\n\n\n\n\nLab Resources\nIt is quite important to try all examples in the lecture notes. You have two options:\n\nUse online compilers (Quick and easy):\n\nOneCompiler.com\n\nSee Lab(1)\n\n\n\nGrading\n\n\n\nActivity\nWeight\n\n\n\n\nLabs\n40%\n\n\nFinal Exam\n60%\n\n\n\n\n\nTentative Schedule\n\n\n\nWeek #\nTopic\nKip\nAssignment\n\n\n\n\n\nWeek 1\nBasic Concepts\nCh.1-2\n\n\n\n\nWeek 2\nAssembly Language Fundamentals\nCh.3-4\nLab(1)"
  },
  {
    "objectID": "exercises/inclass02.html",
    "href": "exercises/inclass02.html",
    "title": "Exercise 2",
    "section": "",
    "text": "Declare four symbolic constants that represent integer 25 in decimal, binary, octal, and hexadecimal formats.\nGiven the number 456789ABh, list out its byte values in little-endian order.\nGiven the number 456789ABh, list out its byte values in big-endian order.\nDefine an array of 120 uninitialized unsigned doubleword values.\nDefine an array of byte and initialize it to the first 5 letters of the alphabet.\nDefine a 32-bit signed integer variable and initialize it with the smallest possible negative decimal value. (Hint: Refer to integer ranges in Chapter 1.)\nDefine an unsigned 16-bit integer variable named wArray and initialize it with three values of your choice.\nDefine a string variable containing the name of your favorite color. Initialize it as a null-terminated string.\nDefine an uninitialized array of 50 signed doublewords named dArray.\nDefine a string variable containing the word “TEST” repeated 500 times.\nDefine an array of 20 unsigned bytes named bArray and initialize all elements to zero.\nTell whether each of the following instructions is legal or illegal. W1 and W2 are word variables, and D1 and D2 are doubleword variables.\n\n\n\nMOV AL, BH\nMOV EAX, 1\nXCHG [W1], [D1]\nMOV EDX, [W1]"
  },
  {
    "objectID": "exercises/inclass01.html",
    "href": "exercises/inclass01.html",
    "title": "Exercise 1",
    "section": "",
    "text": "What is the decimal representation of each of the following unsigned binary integers?\n\n\n\n00110101\n10010110\n11001100\n\n\n\nWhat is the sum of each pair of binary integers?\n\n\n\n10101111 + 11011011\n10010111 + 11111111\n01110101 + 10101100\n\n\n\nWhat is the decimal representation of each of the following 8-bit signed binary numbers?\n\n\n\n10110101\n00101010\n11110000\n\n\n\nWhat is the decimal representation of each of the following signed binary numbers? Without calculation\n\n\n\n10000000\n11111111\n01111111\n\n\n\nWhat is the hexadecimal representation of each of the following binary numbers?\n\n\n\n0011 0101 1101 1010\n1100 1110 1010 0011\n1111 1110 1101 1011\n\n\n\nWhat is the binary representation of the following hexadecimal numbers?\n\n\n\n0126F9D4\n6ACDFA95\nF69BDC2A\n\n\n\nCalculate binary 00001101 minus 00000111.\nCalculate -126 - 3 after converting each number to 8-bit binary number."
  },
  {
    "objectID": "exercises/inclass03.html",
    "href": "exercises/inclass03.html",
    "title": "Exercise 3",
    "section": "",
    "text": "Consider the following code:\n        section .data\nvarA:   db      10h\n        db      20h, 30h\nvarB:   dd      405060h\nvarC:   dw      70h\n\nsection .text\n        mov     eax, [varA]\n        mov     ebx, varC\n        mov     cx, [varB + 2]\n        mov     dh, [varB – 2]\n\nAssume that the data segment starts at address 04004000h when loaded into main memory. Show the content of this data segment. You must display the locations of variables (labels), the content of each memory cell in hexadecimal notation, and memory addresses.\nWhat will be the values of EAX, EBX, CX, and DH in hexadecimal after executing the instructions in the code section?\n\nConsider the following data section (assuming $$ = 0x4004000)\n      section .data\nxarr  dd      1000h, 2000h, 3000h, 4000h\nnum   equ     ($ - xarr)\nyvar  dd      xarr\n\nWhat is the constant value of num after compilation?\nDoes num indicate the number of elements in the array xarr? If not, then modify the definition of num in order to hold the number of elements.\nWhat will be the value of EAX after executing the following instruction:\n        mov     eax, [xarr]\nWhat will be the value of EAX after executing the following instruction:\n        mov     eax, [yvar]"
  },
  {
    "objectID": "lectures/lec01.html",
    "href": "lectures/lec01.html",
    "title": "Lecture 1: Basic Concepts",
    "section": "",
    "text": "Revise the following representations:\n\nBinary integers\n\nUnsigned binary integers:\n\nTranslating unsigned binary integer to decimal\nTranslating unsigned decimal to binary\n\nSigned binary integers:\n\n1’s complement representation\n2’s complement representation\n\n\nHexadecimal integers\n\nHexadecimal 2’s complement\nTranslating binary integer to hexadecimal and vice versa.\nTranslating hexadecimal integer to decimal and vice versa.\n\n\n\n\n\n\n\n\n\nExample\n\n\n\n\nConvert the following number \\((1100101)_2\\) to decimal.\n\\[\\begin{align*}\n     1100101_2 &= 1\\times2^0 + 0\\times2^1 + 1\\times2^2 + 0\\times2^3 + 0\\times2^4 + 1\\times2^5 + 1\\times2^6 \\\\\n     &= 1+4+32+64=101_{10}\n\\end{align*}\\]\nConvert the following number \\((A13)_{16}\\) to decimal.\n\\[\\begin{align*}\n     A13_{16} &= 3\\times16^0 + 1\\times16^1 + 10\\times16^2 \\\\\n     &= 3 + 16 + 2560 = 2579_{10}\n\\end{align*}\\]\nConvert the following number \\(-14_{10}\\) to one-word binary.\n\\[\\begin{align*}\n     14_{10} = 8 + 4 + 2 = 1110_2 &= 0000\\; 0000\\; 0000\\; 1110_2 \\\\\n     Neg &= 1111\\; 1111\\; 1111\\; 0001_2 \\\\\n     +1 &= 1111\\; 1111\\; 1111\\; 0010_2\n\\end{align*}\\]\n\\(\\therefore -14_{10} = 1111\\;1111\\;1111\\;0010_2\\)\nConvert the following number \\(-14_{10}\\) to one-word hexadecimal\n\\(-14_{10}\\) = FFF216\n\n\n\n\nBinary-Coded Decimal (BCD) Numbers:\n\nEvery decimal digit is represented by 4 binary bits, from 0000 to 1001.\nTwo representations: Unpacked BCD and packed BCD.\nIn unpacked BCD, one decimal digit is encoded in each binary byte. While, in packed BCD, two decimal digits are encoded in each binary byte.\n\n\n\n\nDecimal Number\nUnpacked (in Hex)\nPacked (in Hex)\n\n\n\n\n\\((176)_{10}\\)\n01 07 06\n01 76\n\n\n\nInteger storage sizes\n\n\n\nStorage Name\nSize in BYTE\nsize in BITS\n\n\n\n\nbyte\n1\n8\n\n\nword\n2\n16\n\n\ndoubleword\n4\n32\n\n\nquadword\n8\n64\n\n\n\n\n\n\n\n\nCharacters are represented by using character set, which is one-to-one mapping of characters to integers.\n\n\n\nCharacter set\nCharacter size\n\n\n\n\nASCII\n7 bits\n\n\nANSI\n8 bits\n\n\nUTF-8\n8 bits\n\n\nUTF-16\n16 bits\n\n\nUTF-32\n32 bits\n\n\n\nUTF stadnds for Unicode Transformation Format.\nASCII Strings\n\nStrings are stored in memory as a succession of bytes containing ASCII codes. For example, \"ABC123\" is stored in memory as 41h, 42h, 43h, 31h, 32h, and 33h.\nA null-terminated string is a string of characters followed by a single byte containing zero (NULL). For example, the null-terminated string \"ABC123\" is stored in memory as 41h, 42h, 43h, 31h, 32h, 33h, and 00h.\n\n\n\n\n\n\nReal numbers are represented using the binary representation of IEEE 754 Standard.\nThe representation in memory:\n\n\n\nMemory layout for floating point\n\n\nwhere s is the sign bit, e is the exponent, and f is the significand.\n\\(x = (-1)^s (1 + f) \\times 2^m\\), where \\(m = e - bias\\)\nFloating-point Types:\n\n\n\nType\nSize\nExponent\nFraction\nBias\n\n\n\n\nSingle-precision\n32\n8\n23\n127\n\n\nDouble-precision\n64\n11\n52\n1023\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n\nConvert \\(-11.375_{10}\\) to single-precision binary representation?\n\\(11_{10} = (1011)_2\\)\n\\(0.375_{10} = (2^{-2} + 2^{-3}) = 0.25 + 0.125 = (.011)_2\\)\n\n\\(\\therefore 11.375_{10} = (1011.011)_2 = 1.011011 \\times 2^{+3}\\)\nTherefore,\ns = 1 (sign is enabled)\ne = 3 + 127 = 130 = (1000 0010)2\nf = (011011)2\nThe representation is: \\(1100\\,\\,0001 \\,\\, 0011 \\,\\, 0110 \\,\\, 0000 \\,\\, 0000 \\,\\, 0000 \\,\\, 0000_2\\) = C136000016\n\n\n\n\n\n\nConversion\n\n\n\n\n\n\nFloating-point representation is NOT recommended to store money amount. In languages such as Java or C++, floating point values have certain rounding characteristics that make it difficult to compare them for equality. The common example to illustrate the problem is 0.1 + 0.2 != 0.3.\nSome applications use BCD (such as BigInteger class in the Java class library)."
  },
  {
    "objectID": "lectures/lec01.html#data-representation",
    "href": "lectures/lec01.html#data-representation",
    "title": "Lecture 1: Basic Concepts",
    "section": "",
    "text": "Revise the following representations:\n\nBinary integers\n\nUnsigned binary integers:\n\nTranslating unsigned binary integer to decimal\nTranslating unsigned decimal to binary\n\nSigned binary integers:\n\n1’s complement representation\n2’s complement representation\n\n\nHexadecimal integers\n\nHexadecimal 2’s complement\nTranslating binary integer to hexadecimal and vice versa.\nTranslating hexadecimal integer to decimal and vice versa.\n\n\n\n\n\n\n\n\n\nExample\n\n\n\n\nConvert the following number \\((1100101)_2\\) to decimal.\n\\[\\begin{align*}\n     1100101_2 &= 1\\times2^0 + 0\\times2^1 + 1\\times2^2 + 0\\times2^3 + 0\\times2^4 + 1\\times2^5 + 1\\times2^6 \\\\\n     &= 1+4+32+64=101_{10}\n\\end{align*}\\]\nConvert the following number \\((A13)_{16}\\) to decimal.\n\\[\\begin{align*}\n     A13_{16} &= 3\\times16^0 + 1\\times16^1 + 10\\times16^2 \\\\\n     &= 3 + 16 + 2560 = 2579_{10}\n\\end{align*}\\]\nConvert the following number \\(-14_{10}\\) to one-word binary.\n\\[\\begin{align*}\n     14_{10} = 8 + 4 + 2 = 1110_2 &= 0000\\; 0000\\; 0000\\; 1110_2 \\\\\n     Neg &= 1111\\; 1111\\; 1111\\; 0001_2 \\\\\n     +1 &= 1111\\; 1111\\; 1111\\; 0010_2\n\\end{align*}\\]\n\\(\\therefore -14_{10} = 1111\\;1111\\;1111\\;0010_2\\)\nConvert the following number \\(-14_{10}\\) to one-word hexadecimal\n\\(-14_{10}\\) = FFF216\n\n\n\n\nBinary-Coded Decimal (BCD) Numbers:\n\nEvery decimal digit is represented by 4 binary bits, from 0000 to 1001.\nTwo representations: Unpacked BCD and packed BCD.\nIn unpacked BCD, one decimal digit is encoded in each binary byte. While, in packed BCD, two decimal digits are encoded in each binary byte.\n\n\n\n\nDecimal Number\nUnpacked (in Hex)\nPacked (in Hex)\n\n\n\n\n\\((176)_{10}\\)\n01 07 06\n01 76\n\n\n\nInteger storage sizes\n\n\n\nStorage Name\nSize in BYTE\nsize in BITS\n\n\n\n\nbyte\n1\n8\n\n\nword\n2\n16\n\n\ndoubleword\n4\n32\n\n\nquadword\n8\n64\n\n\n\n\n\n\n\n\nCharacters are represented by using character set, which is one-to-one mapping of characters to integers.\n\n\n\nCharacter set\nCharacter size\n\n\n\n\nASCII\n7 bits\n\n\nANSI\n8 bits\n\n\nUTF-8\n8 bits\n\n\nUTF-16\n16 bits\n\n\nUTF-32\n32 bits\n\n\n\nUTF stadnds for Unicode Transformation Format.\nASCII Strings\n\nStrings are stored in memory as a succession of bytes containing ASCII codes. For example, \"ABC123\" is stored in memory as 41h, 42h, 43h, 31h, 32h, and 33h.\nA null-terminated string is a string of characters followed by a single byte containing zero (NULL). For example, the null-terminated string \"ABC123\" is stored in memory as 41h, 42h, 43h, 31h, 32h, 33h, and 00h.\n\n\n\n\n\n\nReal numbers are represented using the binary representation of IEEE 754 Standard.\nThe representation in memory:\n\n\n\nMemory layout for floating point\n\n\nwhere s is the sign bit, e is the exponent, and f is the significand.\n\\(x = (-1)^s (1 + f) \\times 2^m\\), where \\(m = e - bias\\)\nFloating-point Types:\n\n\n\nType\nSize\nExponent\nFraction\nBias\n\n\n\n\nSingle-precision\n32\n8\n23\n127\n\n\nDouble-precision\n64\n11\n52\n1023\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n\nConvert \\(-11.375_{10}\\) to single-precision binary representation?\n\\(11_{10} = (1011)_2\\)\n\\(0.375_{10} = (2^{-2} + 2^{-3}) = 0.25 + 0.125 = (.011)_2\\)\n\n\\(\\therefore 11.375_{10} = (1011.011)_2 = 1.011011 \\times 2^{+3}\\)\nTherefore,\ns = 1 (sign is enabled)\ne = 3 + 127 = 130 = (1000 0010)2\nf = (011011)2\nThe representation is: \\(1100\\,\\,0001 \\,\\, 0011 \\,\\, 0110 \\,\\, 0000 \\,\\, 0000 \\,\\, 0000 \\,\\, 0000_2\\) = C136000016\n\n\n\n\n\n\nConversion\n\n\n\n\n\n\nFloating-point representation is NOT recommended to store money amount. In languages such as Java or C++, floating point values have certain rounding characteristics that make it difficult to compare them for equality. The common example to illustrate the problem is 0.1 + 0.2 != 0.3.\nSome applications use BCD (such as BigInteger class in the Java class library)."
  },
  {
    "objectID": "lectures/lec01.html#intel-microprocessors",
    "href": "lectures/lec01.html#intel-microprocessors",
    "title": "Lecture 1: Basic Concepts",
    "section": "Intel Microprocessors",
    "text": "Intel Microprocessors\n\nConventionally, Intel microprocessors are known as x86 processors.\nx86 microprocessors are divided into three families: x86-16, x86-32 and x86-64.\nAll Intel microprocessors are byte addressable.\nIn 1974, Intel has announced 8080 CPU: 8-bit CPU (2Mhz) and 16-bit address bus (64KB).\nIn 1978, 8086 CPU has been introduced with 16-bit CPU (16-bit registers and 16-bit external data bus) and 20-bit address bus with CPU speed ranging from 5MHz to 10MHz.\n\nMemory addresses start from 000000H to 0FFFFFH (1MB)\nThe address space is divided into segments. A segment is a region of memory that begins on a paragraph boundary and extends for some number of bytes (&lt;= 64K).\nA paragraph is a measure of memory equal to 16 bytes.\n8086 CPUs have four 16-bit segment registers: CS, DS, SS, and ES. -The physical address is constructed by two registers: segment address : offset address.\n\nIn 1982, Intel 286 introduced protected mode operation with four privilege levels. The address bus was 24-bit providing 16MB physical memory.\nThe Intel 386 (1985) was the first 32-bit CPU (80386 CPUs) with 32-bit address bus (addressable up to 4G).\n\n80386 CPUs are backward compatible with 8086 CPUs and hence the term x86 family.\nIn addition, it supports for :\n\nA segmented–memory model and a flat memory model.\nPaging, with a fixed 4KB page size providing a method for virtual memory management.\nSupport for 3-stage instruction pipeline (Fetch-Decode-Execute) .\n\n\nIntel 486 (1989) processors are all based on IA-32 architecture with additional support for parallel execution capabilities (ILP):\n\nIt supports 5-stage instruction pipeline.\nIt supports 8KB on-chip L1-cache (using Write-through policy)\nIt has an integrated x87 FPU\n\nIntel Pentium Processor (1993), also known unofficially as P5 or Intel 586, marked a significant advancement in microarchitecture technology. It supports:\n\nSuperscalar architecture, which allows to execute more than one instruction per clock cycle\n8KB L1 cache devoted for code and another 8KB L1 cache devoted for data.\nIntroduced MMX technology, which uses the single-instruction, multiple data (SIMD) execution model with 64-bit registers.\n\nIntel P6 Family (1995-1999), which includes Intel Pentium Pro, Intel Pentium II and III, and Intel Celeron, was introduced.\nIntel 64 architecture was introduced in the Intel Pentium 4 Processor (Extreme Edition) in 2005.\nThe 2010 Intel processor family (First Generation) spans Intel Core i7, i5 and i3 processors. In 2017, Intel Core i9 was introduced. The current generation is 14. Intel currently has several sub-families:\n\nIntel Xeon Processors for data centers and workstations.\nIntel Core Ultra Processors for AI and immersive graphics.\nIntel Core Processors for laptops and desktops.\nIntel Atom Processors for mobile and IoT devices"
  },
  {
    "objectID": "lectures/lec01.html#ia-32-basic-execution-environment",
    "href": "lectures/lec01.html#ia-32-basic-execution-environment",
    "title": "Lecture 1: Basic Concepts",
    "section": "IA-32 Basic Execution Environment",
    "text": "IA-32 Basic Execution Environment\nAs an assembly programmer, you should know the execution environment either for IA-32 or Intel 64 processor.\nAny program running on an IA-32 processor is given a set of resources for executing instructions and for storing code, data and state information.\nThe basic execution environment includes memory (the address space), general purpose data registers, segment registers, the flag register, and the instruction pointer register.\n\nModes of Operation in IA-32\nModes of operation define the memory layout and how a program can address memory (using registers). It also determines which instructions are accessible.\nIA-32 processors have three primary modes of operation:\n\nProtected mode, in which programs are given separate memory areas named segments, and the processor prevents programs from referencing memory outside their assigned segments. This is the default mode.\nReal–Adress mode, in which programs can access to system memory and hardware devices. OS prevents programmers to swtich to this mode.\nSystem Management mode, in which it provides an OS with a mechanism for implementing functions such as power management and system security. These functions are usually implemented by computer manufacturers.\n\nA sub–mode, named virtual-8086, is a special case of protected mode, in which MS–DOS programs (real-mode software) can be executed in a safe environment.\n\nModes of Operations in Intel 64\nThe Intel 64 architecture adds IA-32e mode, which has two sub-modes:\n\ncompatibility mode, which permits legacy 16-bit and 32-bit applications to run without re-compilation under a 64-bit Operating System. Compatibility mode is similar to 32-bit protected mode.\n64-bit mode, which enables a program to access 64-bit linear address space.\n\n\n\n\nCPU Registers\n\nSegment Registers\n\nThe 8086, 8088 and and 80286 have exactly four segment registers specifically designated as holders of segment address.\nThe 80386 and later CPUs have two more that can be used in real mode.\nThe segment registers:\n\nCS, which stands for code segment\nDS, which stadnds for data segment\nSS, which stands for stack segment\nES, which stands for extra segment.\nFS and GS. They are both additional “extra” segments.\n\nAll segment registers are 16 bits in size, irrespective of the CPU architecture.\nSegment registers was to allow 20 bits of address space to be addressed by two 16-bit registers (in the form of segment address : offset address).\nIn IA-32 architecture, segment registers are used only by the operating system.\nThe segment registers are not used in x64 architecture.\n\n\n\nGeneral-Purpose Registers (GPRs)\n\nThe 32-bit GPRs are EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP.\nGPRs are primarily used for\n\narithmetic and logical operations.\naddress calculations.\nmemory pointers\n\nAlthough all of these registers are available for general storage of operands, ESP register holds the stack pointer and as general rule should not be used for another purpose.\n\n\n\nSome general-purpose registers have specialized uses:\n\nEAX is used for multiplication and division instructions.\nECX is automatically used as loop counter.\nESP addresses data on the stack.\nESI and EDI are used by high–speed memory transfer instructions.\nEBP is used by high–level languages to reference function parameters and local variables on the stack. It should not be used for ordinary arithmetic or data transfer.\n\n\n\n\nThe Flag Register (EFLAGS register)\n\n\nEFLAGS consists of individual binary bits that control the CPU operation or reflect the status of last executed instruction\nSome instructions test and manipulate individual flags\nA flag is set when it equals 1; it is clear when it equals 0.\nSome of the flags in the EFLAGS register can be modified directly, using special-purpose instructions.\nThe status flags (bits 0, 2, 4, 6, 7, and 11) of the EFLAGS register indicate the results of arithmetic instructions, such as the ADD, SUB, MUL, and DIV instructions. The functions of the status flags are as follows:\n\n\n\n\n\n\n\nFlag\nDescription\n\n\n\n\nCF (bit 0)\nCarry flag. Set if an arithmetic operation generates a carry or a borrow out of the most-significant bit of the result; cleared otherwise. This flag indicates an overflow condition for unsigned-integer arithmetic. It is also used in multiple-precision arithmetic.\n\n\nPF (bit 2)\nParity flag. Set if the least-significant byte of the result contains an even number of 1 bits; cleared otherwise.\n\n\nAF (bit 4)\nAdjust flag. Set if an arithmetic operation generates a carry or a borrow out of bit 3 of the result; cleared otherwise. This flag is used in binary-coded decimal (BCD) arithmetic.\n\n\nZF (bit 6)\nZero flag. Set if the result is zero; cleared otherwise.\n\n\nSF (bit 7)\nSign flag. Set equal to the most-significant bit of the result, which is the sign bit of a signed integer. (0 indicates a positive value and 1 indicates a negative value.)\n\n\nOF (bit 11)\nOverflow flag. Set if the integer result is too large a positive number or too small a negative number (excluding the sign-bit) to fit in the destination operand; cleared otherwise. This flag indicates an over flow condition for signed-integer (two’s complement) arithmetic.\n\n\n\nOf these status flags, only the CF flag can be modified directly, using the STC, CLC, and CMC instructions. Also the bit instructions (BT, BTS, BTR, and BTC) copy a specified bit into the CF flag.\n\n\n\n\nAddress Space\n\nThe memory that the processor addresses on its bus is called physical memory.\nPhysical memory is organized as a sequence of 8-bit bytes. Each memory byte is assigned a unique address, called a physical address. In IA-32 architecture, physical addresses range from zero to a maximum of 232−1 (or 236−1 when Physical Address Extension PAE is enabled).\nx86 memory has three major memory models, which are:\n\nReal-mode flat model\nReal-mode segmented model\n32-bit protected-mode flat model\n64-bit long mode (will be discussed later in this course)\n\n\n\nReal-Mode Flat Model\n\nIn real-mode flat model, a program and all the data it works on must exist within a single 64KB block of memory.\nThe segment registers are all set to point to the beginning of the 64KB block of memory (The OS sets them when it loads and runs the program).\n\n\n\nReal-Mode Segmented Model\n\nYour program can still see 1MB of memory available to the CPU in real mode. However, the 20-bit address is constructed by combining the 16-bit segment address with 16-bit offset address.\n\n\n\n32-Bit Protected Mode Flat Model\n\nIn 32-bit protected mode, a program can address a linear address space of up to 4GB.\n\nEach address is 32-bit quantity including the EIP.\nThe segment registers are still exist, but controlled by the operating system. You, as programmer, neither read nor change them directly. The segment registers define where your 4GB memory space exists in physical or virtual memory."
  },
  {
    "objectID": "lectures/lec01.html#assembly-language",
    "href": "lectures/lec01.html#assembly-language",
    "title": "Lecture 1: Basic Concepts",
    "section": "Assembly Language",
    "text": "Assembly Language\n\nWhat is Assembly Language\n\nAssembly Language is the oldest programming language, bears the closest resemblance to native machine language. Hence, assembly language is a low-level programming language.\nAssembly language for x86 (the focus of this course) means programming on microprocessors compatible with Intel and AMD processors running under Windows, Linux, Unix, etc.\n\n\n\nMachine Language\n\nA CPU can only execute machine instructions. These instructions are bit strings. The following is a short program written in machine language for the IBM PC:\n\n\n\nMachine Instruction\nDescription\n\n\n\n\n10100001 00000000 00000000\nMove content of memory word 0 to AX\n\n\n00000101 00000100 00000000\nAdd 4 to AX\n\n\n10100011 00000000 00000000\nMove content of AX to memory word 0\n\n\n\nA more convenient language to use is assembly language. It uses symbolic names to represent operations, registers, and/or memory location. If memory location 0 is symbolized by A, the preceding program can be expressed like this in assembly language:\nmov   ax, [A]   ; move content of A to AX\nadd   ax, 4     ; add 4 to the content of AX\nmov   [A], ax   ; move content of AX to A\n\n\n\nAssembly Language Compared to High-Level Language\nThe following assignment statement (C/C++):\nint y = (x + 10) * 3;\ncan be translated to Assembly language as follows:\nmov   eax, [x]    ; move content of x to EAX register\nadd   eax, 10     ; Add 10 to EAX\nmov   ebx, 3      ; Let EBX = 3\nimul  ebx         ; perform EAX = EAX * EBX\nmov   [y], eax    ; store the result into Y\n\n\nIs Assembly Language Portable?\n\nA language whose source programs can be compiled and run on a wide variety of computer systems is said to be portable.\n\nJava is portable, compiled programs run nearly on any computer\nC++ is portable, can compile and run on any computer if standard library is used\n\nAssembly is NOT portable, because it is designed for a specific processor family and operating system.\n\n\n\nWhy Learning Assembly Language\n\nEfficiency in terms of size and time, because assembly language is so close to machine language\nWriting system programs (Operating system, Embedded programming, device driver, etc)\n\n\n\nThe Assembler\n\nUnfortunately, there is no standardization for x86 assembly language like other high-level languages, such as C and C++\nThe assembly language mainly depends on\n\nthe instruction set (ISA) of a microprocessor, and\na utility program called assembler.\n\n\n\n\nAn assembler: is a utility program that converts source code programs from assembly language into machine language (known as object source file).\nThere are many different assemblers out there for x86 architecture:\n\nMASM (Microsoft Macro Assembler)\nNASM (Netwide Assembler)\nTASM (Turbo Assembler)\nGAS (GNU Assembler)\n… and many more\n\nAll x86 assemblers use radically different assembly language\n\nThey agree on the instruction set (Like MOV, ADD, SUB, etc)\nThey differ on how the registers are used and how the operands are addressed.\n\nThis course will consider NASM assembler.\n\n\nNASM Assembler\n\nThe Netwide Assembler, NASM, is an IA-32 and Intel 64 assembler designed for portability and modularity\nNASM is a free cross-platform x86 assembler which supports all common x86 operating systems: Windows, Linux, MacOS X, Unix, etc.\nNASM provides a simple syntax that closely resembles Intel’s assembly language while offering compatibility with a variety of output formats, such as ELF, COFF, and Mach-O.\n\n\n\n\nProgramming Tools That You Need\n\nTo develop an assembly program, you need\n\nan assembler, which we are going to use NASM\nan editor; there are several choices\n\nVisual Studio Code\nNotepad++\nVIM under Linux\n\nA Linker: is a utility program that combines individual object files created by an assembler into a single executable program.\n(Optionally) a debugger, in case you need to debug your code.\n\n\n\nBuilding Process\n\n\n\nObject File Format\n\nCompilers and assemblers create object files containing the generated machine code and data for a source file. Linkers combine multiple object files into one binary file (known as image file or executable file). Loaders take image files and load them into memory (in order to be executed).\n\n\n\n\n\n\n\nWhat goes into object file?\n\n\n\n\nHeader information,\nRelocation table,\nSymbols,\nDebugging information, and\nof course, Machine code\n\n\n\n\nThere are many object file formats. Some you should know about include:\n\nCOFF, primary for UNIX\nWin32 and Win64, primary for Windows OS\nELF and ELF64, primary for Linux\nMacho32 and Macho64, primary for MacOS X"
  }
]