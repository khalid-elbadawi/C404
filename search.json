[
  {
    "objectID": "lectures/lec05.html",
    "href": "lectures/lec05.html",
    "title": "Lecture 5: Procedures",
    "section": "",
    "text": "Understand the run-time stack operations.\nLearn how to define a procedure and how to call it."
  },
  {
    "objectID": "lectures/lec05.html#objectives",
    "href": "lectures/lec05.html#objectives",
    "title": "Lecture 5: Procedures",
    "section": "",
    "text": "Understand the run-time stack operations.\nLearn how to define a procedure and how to call it."
  },
  {
    "objectID": "lectures/lec05.html#stack-operations",
    "href": "lectures/lec05.html#stack-operations",
    "title": "Lecture 5: Procedures",
    "section": "Stack Operations",
    "text": "Stack Operations\n\nA stack is a data structure that is often called LIFO structure (Last-In, First-Out) because the last value put into the stack is always the first value taken out.\nA stack is associated with two operations: Push and Pop.\n\nPush is an operation to add an element into the stack (at the top)\nPop is an operation to remove one element from the stack (from the top)\n\n\n\n\nRun-time Stack\n\nEach process (a running program) has a run-time stack, which is a memory block managed directly by the CPU.\nIn 32-bit mode, the ESP register (known as the stack pointer) holds a 32-bit offset into some location on the stack.\nESP always points to the top of the run-time stack.\nESP can be manipulated manually or by CPU instructions: PUSH, POP, CALL and RET.\n\n\n\nESP points to the top of the stack. The area above ESP (in light red) is inside the stack. The area below the ESP (light blue) is empty.\n\n\n\n\n\nPUSH Instruction\n\n\n\n\n\n\nSyntax\n\n\n\n      PUSH    &lt;source&gt;\n\n\n\nThe source operand can be either 16-bit value or 32-bit value.\nThe push operation performs the following two steps (in order):\n\nIt decrements the stack pointer (ESP) by the appropriate amount according to the size of the source operand:\n\nif the source operand is 32-bit, the stack pointer is decremented by a value of 4\nif the source operand is 16-bit, the stack pointer is decremented by a value of 2.\n\nIt copies a value into the location in the stack referenced by the stack pointer.\n\nThe valid formats are:\n      push    reg/mem32\n      push    reg/mem16\n      push    imm32\nExample:\n      push    2024    ; 2024 =&gt; 000007E8h\n\nLet us consider the following run-time stack as shown below; before executing push instruction:\n\nWhen push 2024 is executed, the first step is to decrement ESP by 4.\n\nThen, the value 2024 , which will be treated as imm32, will be copied onto the stack at the location referenced by ESP:\n\nThe above diagram shows the stack after pushing a total of four bytes.\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe area of the stack below ESP (at lower addresses) is logically empty, and will be overwritten the next time the current program executes any instruction that pushes a value on the stack.\n\n\n\n\nPOP Instruction\n\n\n\n\n\n\nSyntax\n\n\n\n      POP   &lt;destination&gt;\n\n\n\nThe destination operand can be of size either 16-bit or 32-bit.\nThe valid formats are:\n    pop   reg/mem16\n    pop   reg/mem32\nThe pop operation performs the following steps (in order):\n\nIt copies the value in the stack referenced by the stack pointer into the destination operand. The number of bytes to be copied is determined by the size of the destination operand.\n\nIf the size of destination operand is 16-bit, then two bytes are tranferred into the destination operand.\nIf the size of destination operand is 32-bit, then four bytes are transferred into the destination operand\n\nIt increments the stack pointer by the appropriate amount according to the size of the destination operand (i.e, either 2 bytes or 4 bytes).\n\nExample: Let us consider the previous state of the run-time stack. The following instruction pop the top value (which is 2024), and put it into EAX register:\n      pop   eax\n\n\n\nFlags Affected\nBoth push and pop instructions have no effect on EFLAGS register.\n\n\n\nPUSHA and POPA Instructions\n\n\n\n\n\n\nSyntax\n\n\n\n      PUSHA       ; no operand\n      \n      POPA        ; no operand\n\n\n\nPUSHA (push all) pushes the contents of the 16-bit general-purpose registers onto the stack. The registers are stored on the stack in the following order: AX, CX, DX, BX, SP, BP, SI, and DI.\nPOPA (pop all) pops words from the stack into the 16-bit general purpose registers in the following order: DI, SI, BP, BX, DX, CX, and AX. The value on the stack for SP register is ignored.\n\n\n\nPUSHAD and POPAD Instructions\n\n\n\n\n\n\nSyntax\n\n\n\n      PUSHAD       ; no operand\n      \n      POPAD        ; no operand\n\n\n\nPUSHAD (push all doublewords) pushes the contents of the 32-bit general-purpose registers onto the stack. The registers are stored on the stack in the following order: EAX, ECX, EDX, EBX, ESP (original value), EBP, ESI, and EDI.\nPOPAD (pop all doublewords) pops doublewords from the stack into the 32-bit general purpose registers in the following order: EDI, ESI, EBP, EBX, EDX, ECX, and EAX. The value on the stack for ESP register is ignored.\n\n\n\nPUSHFD and POPFD Instructions\n\n\n\n\n\n\nSyntax\n\n\n\n      PUSHAD       ; no operand              POPAD        ; no operand\n\n\n\nPUSHFD (push flag doubleword) pushes the contents of the 32-bit EFLAGS register onto the stack.\nPOPFD (pop flag doubleword) pops a doubleword from the stack into the 32-bit EFLAGS register.\n\n\n\nStack Applications\n\nInvoking C Standard Library\n\nWe can invoke C standard functions from inside assembly program, such as printf().\nThe instruction CALL is used to invoke a function. The following program prints out “Welcome to Assembly Language” to screen monitor (output console).\n\n        global _main\n        extern _printf      ; tell assembler that printf() is an\n                            ; external function\n        \n        section .data\nmessage db      \"Welcome to Assembly Language\", 0\n\n        section .code\n_main:\n        push    message     ; push message as argument\n        call    _printf     ; call printf() \n        add     esp, 4      ; to pop out message\n        \n        ret\n\n\nReverse a String\n\nLet’s look at a program that loops through a string and pushes each character on the stack. It then pops the letters from the stack and stores them back into the same string variable. Because the stack is a LIFO (last-in, first-out) structure, the letters in the string are reversed:\n\n            global  _main\n            extern  _printf      ; C standard function\n            \n            section .data\nmsg         db      \"Hello World!\", 0\n\n            section .text\n            \n_main:\n            mov     esi, 0\nL1:         movzx   ax, BYTE [esi + msg]\n            cmp     ax, 0\n            jz      ENDL1\n            push    ax\n            inc     esi\n            jmp     L1\nENDL1:\n            mov     ecx, esi\n            mov     esi, 0\nL2:         pop     ax\n            mov     [esi + msg], al\n            inc     esi\n            loop    L2\n            \n            push    msg\n            call    _printf\n            add     esp, 4\n\n            xor     eax, eax\n            ret\n\n\nMemory to Memory Transfer\n\nLet translate the following statement into assembly language using run-time stack:\ny = x;      /* assign x to y */\n      push  DWORD[x]\n      pop   DWORD[y]\nLet us also swap two values x and y using run-time stack:\n      push  DWORD[x]\n      push  DWORD[y]\n      pop   DWORD[x]\n      pop   DWORD[y]\n\n\n\nNested Loop\n\nRecall that you need to maintain the counter value(s) of the outer loop(s)\n      mov   ecx, 100    ; outer loop index\nOUTER:\n      push  ecx         ; store outer loop index\n      mov   ecx, 20\nINNER:\n      .\n      .\n      loop  INNER\n\n      pop   ecx         ; restore outer loop index\n      loop  OUTER"
  },
  {
    "objectID": "lectures/lec05.html#procedures",
    "href": "lectures/lec05.html#procedures",
    "title": "Lecture 5: Procedures",
    "section": "Procedures",
    "text": "Procedures\n\nA complicated problem is usually divided into separate tasks before it can be understood, implemented, and tested effectively.\nThis is known as Procedure-Oriented Programming (POP).\nIn assembly language, we typically use the term procedure to mean the assembly language implementation of POP paradigm.\nIn other programming languages, procedures are often called functions or subroutines.\nIn NASM, a procedure can be placed anywhere in TEXT segment; before _main label, after ret instruction, or between _main and ret.\nNASM has no built-in directive to support procedures. However, MASM, the other assembler, has built-in directive: PROC and ENDP.\n\n\nCALL and RET Instructions\n\n\n\n\n\n\nSyntax\n\n\n\n        CALL    &lt;destination&gt;\n\n\n\nWe know that the CPU fetches the instruction in memory pointed by EIP register, also known as Program Counter (PC).\nAfter fetching the instruction, the PC is automatically incremented.\nWhen the instruction is executed, the PC will be already pointing to the next instruction.\nTherefore, the CALL instruction performs the following operations:\n\nit pushes the current value of PC onto the run-time stack. Then,\nIt jumps to the destination address.\n\nThe RET instruction simply pops from stack into the PC. Therefore, the EIP register will execute the instruction that follows the CALL instruction.\n\n\nExample 1 In the following example, the procedure initialize sets EAX, EBX, ECX and EDX to zero. In the main program, we call this procedure to initialize data registers to zero.\ninitialize:\n      xor   eax, eax\n      xor   ebx, ebx\n      xor   ecx, ecx\n      xor   edx, edx\n      ret               ; end of initialize procedure\n      \n_main:\n      call  initialize\n      .\n      .\n      .\n      ret               ; end of main program\n\n\nHow the CPU Executes CALL and RET Instructions\n\nThe following diagrams show a program in execution along with its run-time stack. All addresses are shown in decimal format (not hexadecimal).\nIn Figure 1, the program is fetching \\(instruction_1\\) , which is located at address \\(4000\\).\n\n\n\n\n\n\nFigure 1\n\n\n\nWhen the CPU starts to execute \\(instruction_1\\) , the EIP is pointing to \\(instruction_2\\), as shown in Figure 2. After instruction execution, the CPU will fetch \\(instruction_2\\).\n\n\n\n\n\n\nFigure 2\n\n\n\nWhen the CPU starts to execute \\(instruction_2\\), the EIP is incremented and pointing to the instruction at location \\(4008\\), as shown in Figure 3.\n\n\n\n\n\n\nFigure 3\n\n\n\nAfter executing \\(instruction_2\\), the CPU will fetch CALL foo instruction. Before executing this instruction, the EIP is incremented to \\(4010\\), as shown in Figure 4.\n\n\n\n\n\n\nFigure 4\n\n\n\nThe CALL instruction, when executed, will perform the following two operations:\n\nfirst, It pushes the current value of EIP onto the stack.\nsecond, It replaces the value of EIP with the offset address FOO (which has the value \\(4400\\)). So, the CPU will branch to that address, as illustrated in Figure 5.\n\n\n\n\n\n\n\nFigure 5\n\n\n\nLogically, the CPU will start to execute the procedure FOO.\nThe CPU will execute \\(instruction_1\\), \\(instruction_2\\), and \\(instruction_3\\) of procedure FOO, which are located at \\(4400\\), \\(4402\\), and \\(4406\\), respectively.\nAfter executing \\(instruction_3\\) of procedure FOO, the EIP is pointing to the next instruction, which is RET. See Figure 6.\n\n\n\n\n\n\nFigure 6\n\n\n\nWhen the CPU executes RET instruction, it will implicitly perform the following instruction: pop  EIP. This implies that the value in EIP will be replaced with the value pointed by ESP. Then, the ESP will be incremented by 4. as shown in Figure 7. Consequently, the CPU will branch back to the instruction that follows the CALL instruction.\n\n\n\n\n\n\nFigure 7\n\n\n\n\n\n\n\n\n\n\nStack Buffer Overflow\n\n\n\nThe EIP register cannot be accessed directly by software; it is controlled implicitly by control-transfer instructions (such as JMP, Jcc, CALL, and RET), interrupts, and exceptions. The only way to read the EIP register is to execute a CALL instruction and then read the value of the return instruction pointer from the procedure stack. The EIP register can be loaded indirectly by modifying the value of a return instruction pointer on the procedure stack and executing a return instruction (RET or IRET).\nA stack buffer overflow can be caused deliberately as part of an attack known as stack smashing. If the run-time stack is filled with data supplied from an untrusted user then that user can corrupt the stack in such a way as to inject executable code into the running program and take control of the process. This is one of the oldest and more reliable methods for attackers to gain unauthorized access to a computer.\n\n\n\n\n\nNested Procedure Call\n\nA called procedure can call another procedure before the first procedure returns. This is known as nested procedure call.\nSuppose the main procedure calls a procedure named Sub1. While Sub1 is executing, it calls the Sub2 procedure. While Sub2 is executing, it calls the Sub3 procedure. The process is shown in Figure 8.\n\n\n\n\n\n\nFigure 8\n\n\n\n\n\n\nPassing Register Arguments to Procedures\n\nSuppose we have two vectors: vec1 and vec2. The size of the two vectores are defined in a constant label named VECSIZE.\nThe procedure addVectors adds two vectors (i.e., vec1 + vec2) and stores the resulted vector in vec1. Here is the code:\naddVectors:\n      mov   esi, 0\n      mov   ecx, VECSIZE\ntop:\n      mov   eax, [esi*4 + vec1]\n      add   eax, [esi*4 + vec2]\n      mov   [esi*4 + vec1], eax\n      inc   esi\n      loop  top\nIf you call the procedure, it could only add two specific vectors (vec1 and vec2 ONLY). If we have another two vectors, then you need to write another procedure.\nIt’s not a good idea to include references to specific variable names inside the procedure.\nA better approach is to pass the offset of an array to the procedure and pass an integer specifying the number of array elements. Here is a better solution:\naddVectors:\n      push    edi         ; EDI is pointing to the destination vector\n      push    esi         ; EDI is pointing to the source vector\n      push    ecx         ; ECX has the number of elements in the two vectors.\ntop:\n      mov     eax, [edi]\n      add     eax, [esi]\n      mov     [edi], eax\n      add     esi, 4      ; goto next element\n      add     edi, 4      ; goto next element\n      loop    top\n\n      pop     ecx         ; restore ECX\n      pop     esi         ; restore ESI\n      pop     edi         ; restore EDI\n      ret\nThe registers ESI, EDI and ECX are known as arguments.\nIn the main program, you should call the procedure as follows:\n      mov   edi, vec1     ; destination vector (first argument)\n      mov   esi, vec2     ; source vector (second argument)\n      mov   ecx, VECSIZE  ; Array size (third argument)\n      call  addVector\nIn assembly language, it is common to pass arguments inside general–purpose registers.\n\n\nSaving and Restoring Registers\n\nIn the addVector example, ECX, EDI and ESI were pushed on the stack at the beginning of the procedure and popped at the end.\nYou should save and restore registers modified by a procedure so that the calling program can be sure that none of its own register values have been overwritten.\nThe exception to this rule pertains to registers used as return values, usually EAX. Do not push and pop them.\n\n\n\n\nDocumenting Procedures\n\nIt is a good practice to document each procedure you have created. The document should contain at least:\n\nA description of all tasks accomplished by the procedure.\nReceives: A list of parameters; state their usage and requirements.\nReturns: A description of values returned by the procedure.\nRequires: Optional list of requirements called preconditions that must be satisfied before the procedure is called.\n\nHere is an example:\n;------------------------------------------------------------\n; Calculates and returns the sum of three 32-bit integers.\n;\n; Receives : EAX, EBX, ECX, the three integers. May be signed \n;            or unsigned\n; Returns  : EAX = sum, and the status flags (Cary, Overflow, \n;            etc) are changed.\n; Requires : nothing\n;------------------------------------------------------------\n\nSumOf:                ; beginning of procedure\n        add eax, ebx\n        add eax, ecx\n        ret           ; end of procedure\n\n\n\n\n\n\n\nExercise\n\n\n\n\nWrite an assembly program to add two vectors A and B to obtain vector C. The program starts by getting the values of A and B from a user, then it prints out the vector C.\n\nSolution:\nThe general algorithm for this problem is as follows:\n\nRead vector A\nRead vector B\nComputer C such that C[i] = A[i] + B[i]\nPrint vector C\n\nThus, we divide our problem into three sub-problems:\n\nReading a vector from a console\nAdding two vectors\nPrinting out a vector to the console\n\nHence, the structure of our program is shown in Figure 9.\n\n\n\n\n\n\nFigure 9\n\n\n\nIn this exercise, we are going to write a separate file for each procedure:\n\nreadvector.asm, which contains readVector procedure.\naddvectors.asm, which contains addVectors procedure.\nprintvector.asm, which contains printVector procedure.\nmain.asm, which contains the main procedure.\n\n;------------------------------------------------\n; File: readvector.asm\n;------------------------------------------------\n            global  readVector\n            extern  _scanf\n            extern  _printf\n\n            section .data\nscan_fmt    db  \"%d\", 0\n\n            section .code\n;------------------------------------------------\n; Read a vector from a console user \n; \n; Receives: \n;   EAX:    Input prompt\n;   EDI:    A pointer to the vector\n;   ECX:    Number of elements in the vector\n;\n; Returns:\n;   A vector pointed by EDI register\n;\n; Requires: Nothing\n;-------------------------------------------------\nreadVector:\n            ; store EDI and ECX\n            push    edi \n            push    ecx \n\n            ; print input prompt\n            push    eax\n            call    _printf\n            pop     eax\n\n            ; restore EDI and ECX\n            pop     ecx\n            pop     edi \ntop:\n            push    ecx         ; store it again\n            push    edi\n            push    scan_fmt\n            call    _scanf\n            add     esp, 4\n            pop     edi\n            pop     ecx\n            \n            add     edi, 4\n            loop    top\n\n            ret\n;------------------------------------------------\n; File: addvectors.asm\n;------------------------------------------------\n            global addVectors\n\n            section .code\n\n;------------------------------------------------\n; Add two vectors \n; \n; Receives: \n;   EAX:    A pointer to the first vector\n;   EBX:    A pointer to the second vector\n;   EDI:    A pointer to the resulted vector\n;   ECX:    Number of elements in the vector\n;\n; Returns:\n;   The new vector pointed by EDI\n;\n; Requires: Nothing\n;-------------------------------------------------\naddVectors:\n            ; save all data registers\n            pushad              \ntop:\n            mov     edx, [eax]\n            add     edx, [ebx]\n            mov     [edi], edx\n\n            add     eax, 4\n            add     ebx, 4\n            add     edi, 4\n            loop    top\n\n            ; restore all data registers\n            popad\n\n            ret\n;------------------------------------------------\n; File: printvector.asm\n;------------------------------------------------\n            global  printVector\n\n            extern  _printf\n\n            section .data\nprintf_fmt  db  \"%d\", 13, 10, 0\n\n            section .code\n;------------------------------------------------\n; Print out vector to the console screen\n; \n; Receives: \n;   EAX:    Output prompt\n;   EDI:    A pointer to the vector\n;   ECX:    Number of elements in the vector\n;\n; Returns: Nothing\n;\n; Requires: Nothing\n;-------------------------------------------------\nprintVector:\n            ; store EDI and ECX\n            push    edi\n            push    ecx\n\n            push    eax\n            call    _printf\n            pop     eax\n\n            ; restore EDI and ECX\n            pop     ecx\n            pop     edi\ntop:\n            push    ecx\n            push    edi\n\n            push    DWORD [edi]\n            push    printf_fmt\n            call    _printf\n            add     esp, 8\n            \n            pop     edi\n            pop     ecx\n\n            add     edi, 4\n            loop    top\n\n            ret\n;------------------------------------------------\n; File: main.asm\n;------------------------------------------------\n            global _main\n            extern readVector\n            extern printVector\n            extern addVectors\n\n            section .data\nprompt1     db      \"Enter vector A:\", 13, 10, 0\nprompt2     db      \"Enter vector B:\", 13, 10, 0\noutput_msg  db      \"Vector C:\", 13, 10, 0\n\nVECSIZE     equ     5   ; number of elements in the vector\n\n            section .bss\nvecA        resd    VECSIZE\nvecB        resd    VECSIZE\nvecC        resd    VECSIZE\n\n            section .code\n;------------------------------------------------\n; The main procedure\n;------------------------------------------------\n_main:\n            mov     eax, prompt1\n            mov     edi, vecA\n            mov     ecx, VECSIZE\n            call    readVector\n\n            mov     eax, prompt2\n            mov     edi, vecB\n            mov     ecx, VECSIZE\n            call    readVector\n\n            mov     eax, vecA\n            mov     ebx, vecB \n            mov     edi, vecC\n            mov     ecx, VECSIZE\n            call    addVectors\n\n            mov     eax, output_msg\n            mov     edi, vecC\n            mov     ecx, VECSIZE\n            call    printVector\n\n            xor     eax, eax\n            ret"
  },
  {
    "objectID": "lectures/lec03.html",
    "href": "lectures/lec03.html",
    "title": "Lecture 3: Binary Arithmetic, Logic and Addressing",
    "section": "",
    "text": "In this lecture, we focus on binary arithmetic and logic instructions that operate on 8-, 16-, and 32-bit numeric data encoded as signed or unsigned binary integers. The instructions include\n\nincrement and decrement\naddition and subtraction\nMultiplication and division\nBitwise Boolean AND, OR, XOR and NOT\n\nIndirect addressing modes."
  },
  {
    "objectID": "lectures/lec03.html#objectives",
    "href": "lectures/lec03.html#objectives",
    "title": "Lecture 3: Binary Arithmetic, Logic and Addressing",
    "section": "",
    "text": "In this lecture, we focus on binary arithmetic and logic instructions that operate on 8-, 16-, and 32-bit numeric data encoded as signed or unsigned binary integers. The instructions include\n\nincrement and decrement\naddition and subtraction\nMultiplication and division\nBitwise Boolean AND, OR, XOR and NOT\n\nIndirect addressing modes."
  },
  {
    "objectID": "lectures/lec03.html#addition-and-subtraction",
    "href": "lectures/lec03.html#addition-and-subtraction",
    "title": "Lecture 3: Binary Arithmetic, Logic and Addressing",
    "section": "Addition and Subtraction",
    "text": "Addition and Subtraction\n\nINC and DEC Instructions\n\n\n\n\n\n\nSyntax\n\n\n\n      INC     &lt;operand&gt;\n      DEC     &lt;operand&gt;\n\n\n\nINC (increment) and DEC (decrement) instructions add 1 and subtract 1 from an operand, respectively.\nThe operand must be either a memory or register. The format is\n\n        inc   reg/mem\n        dec   reg/mem\n\n\nADD and SUB Instructions\n\n\n\n\n\n\nSyntax\n\n\n\n      ADD   &lt;destination&gt;, &lt;source&gt;\n      SUB   &lt;destination&gt;, &lt;source&gt;\n\n\n\nThe ADD instruction adds a source operand to a destination operand. The sum is stored in the destination operand, and the source operand’s value is unchanged.\nThe SUB instruction subtracts a source operand from a destination operand. The result is stored in the destination operand. The source operand’s value is unchanged\n\n\n\n\n\n\n\nRules\n\n\n\n\nBoth operands must be the same size\nBoth operands cannot be memory operands\nThe instruction pointer register (EIP, RIP) cannot be a destination operand\n\n\n\nThe following operand types are permitted for these instructions (both for ADD and SUB):\n      add   reg, reg\n      add   reg, mem\n      add   reg, imm\n      add   mem, reg\n      add   mem, imm\n\n\nNEG Instruction\n\n\n\n\n\n\nSyntax\n\n\n\n      NEG   &lt;operand&gt;\n\n\n\nThe NEG (negate) instruction reverses the sign of an operand by converting the number to its two’s complement. The following operands are permitted:\n      neg   reg/mem\nIntel implements NEG instruction by subtracting the operand from zero (i.e., &lt;operand&gt; = 0 - &lt;operand&gt;)\n\n\n\nExample\n        section .data\nvar1    dd      1000h         ; 4096\nvar2    dd      2000h         ; 8192\n\n        section .text\n        \n        mov     eax, [var1]   ; EAX = 1000h\n        inc     eax           ; EAX = 1001h\n        dec     DWORD [var2]  ; VAR2 = 1FFFh\n        add     eax, [var2]   ; EAX = 1001h + 1FFFh = 3001h\n        sub     [var2], eax   ; [VAR2] = 1FFFh - 1001h = 0FFEh\n        neg     [var1]        ; [VAR1] = FFFF F000h (-4096) \n\n\nImplementing Arithmetic Expressions\nIn the following examples, we are going to learn how to translate high-level expressions into assembly instructions:\n\nExample 1  \n        b = a;\n\nSolution:\n        mov     eax, [a]        ; EAX = a\n        mov     [b], eax        ; b = EAX\n\nExample 2  \n        b = a + 1;\n\nSolution:\n        mov     eax, [a]        ; EAX = a\n        inc     eax             ; EAX ++\n        mov     [b], eax        ; b = EAX\nAnother solution:\n        mov     eax, [a]\n        add     eax, 1\n        mov     [b], eax\nThe following solution is not acceptable because it changes the value of variable a:\n        add     [a], 1          ; ERROR: don't change the variable a\n        mov     eax, [a]\n        mov     [b], eax\nThe following solution has syntax error: memory to memory operands\n        mov     [b], [a]        ; ERROR: memory to memory operands\n        add     [b], 1\n\nExample 3  \n      c = b - a;\n\nSolution:\n        mov     eax, [a]        ; EAX = a\n        mov     ebx, [b]        ; EBX = b\n        sub     ebx, eax        ; EBX -= EAX\n        mov     [c], ebx        ; c = EBX\nAnother solution:\n        mov     eax, [b]        ; EAX = b\n        sub     eax, [a]        ; EAX = EAX - a\n        mov     [c], eax        ; c = EAX\n\nExample 4  \n      y = 5 - y;\n\nSolution:\n        mov     eax, 5          ; EAX = 5\n        sub     eax, [y]        ; EAX = EAX - y\n        mov     [y], eax        ; y = EAX\nAnother solution:\n        neg     [y]             ; y = -y\n        add     [y], 5          ; y += 5\n\nExample 5  \n      c = 2 * (a + b) + 10;\n\nSolution:\n        ; evaluate (a + b)\n        mov     eax, [a]\n        add     eax, [b]\n        \n        ; 2 * (a + b)\n        add     eax, eax\n        \n        ; 2 * (a + b) + 10\n        add     eax, 10\n        \n        ; c = &lt;expr&gt;\n        mov     [c], eax\n\n\nFlags Affected by Arithmetic Instructions\n\nWhen a CPU executes arithmetic instructions, it consequently updates the status flags. (see lecture 1)\nStatus flags provide information whether the output is\n\nPositive or negative\nzero or not zero\ntoo large or too small to fit into the destination operand\nthe parity of least significant byte\n\nThe status flags can be used to activate conditional branching instructions (will be discussed in next lecture).\n\n\n\n\n\n\n\nStatus Flags\nIs set when\n\n\n\n\nCF\nunsigned integer overflow\n\n\nOF\nsigned integer overflow\n\n\nZF\nthe output is zero\n\n\nSF\nthe output is negative\n\n\nPF\nThe least significant byte of the output have even number of 1 bits\n\n\nAF\nthere a 1 bit carried out of position 3 in the least significant byte of the output\n\n\n\n\n\nCarry Flag\nCarry flag is set when:\n\nThere is a carry out of the most significant bit (MSB) when adding two numbers:\n\n\\[\n\\begin{array}{c*{9}{@{\\,}c}}\n        &    & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 \\\\\n        & +  & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 0 \\\\ \\hline\n   CF=1 &    & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1\n\\end{array}\n\\]\n\nThere is a borrow into the MSB when subtracting two numbers\n\n\\[\n\\begin{array}{c*{9}{@{\\,}c}}\n     &   & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\\\\n     & - & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\\\ \\hline\nCF=1 &   & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\n\\end{array}\n\\]\n\n\n\n\n\n\nRemember\n\n\n\n\nIn unsigned arithmetic, watch the carry flag to detect errors\nIn signed arithmetic, the carry flag tells you nothing interesting\n\n\n\n\n\nOverflow Flag\nOverflow flag is when:\n\nthe sum of two numbers with the sign bits off yields a result number with sign bit on.\n\n\\[\n  \\begin{array}{c*{9}{@{\\,}c}}\n       &   & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 \\\\\n       & + & 0 & 1 & 1 & 0 & 0 & 0 & 1 & 0 \\\\ \\hline\n  OF=1 &   & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 1\n  \\end{array}\n\\]\n\nthe sum of two numbers with the sign bits on yields a result number with sign bit off.\n\n\\[\n  \\begin{array}{c*{9}{@{\\,}c}}\n       &   & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 1 \\\\\n       & + & 1 & 0 & 1 & 0 & 0 & 0 & 1 & 0 \\\\ \\hline\n  OF=1 &   & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 1\n  \\end{array}\n\\]\n\n\nHow the ALU calculates the Overflow flag\nThis material is optional reading.\n\nThe value that carries out of the MSB is exclusive ORed with the carry into the MSB of the result.\nThe value that borrows out of the MSB is exclusive ORed with the borrow into the MSB of the result.\nThe resulting value of XOR is placed in the Overflow flag.\nExample\n\n\\[\n  \\begin{array}{c*{9}{@{\\,}c}}\n       &   & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n       & + & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\ \\hline\n  OF=1 &   & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1\n  \\end{array}\n\\]\nThe carry into the MSB is 0 and the carry out of the MSB is 1, OF = 0 XOR 1 = 1\n\\[\n  \\begin{array}{c*{9}{@{\\,}c}}\n       &   & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\\\\n       & - & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\\\ \\hline\n  OF=0 &   & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\n  \\end{array}\n\\]\nThe borrow into the MSB is 1 and the borrow out of the MSB is 1, OF = 1 XOR 1 = 0\n\n\n\n\n\n\nRemember\n\n\n\n\nIn signed arithmetic, watch the overflow flag to detect errors\nIn unsigned arithmetic, the overflow flag tells you nothing interesting\n\n\n\n\n\n\nWhich Instructions Affect Flags\n\nIn general, each time the processor executes an instruction, the flags are altered to reflect the result. However, some instructions don’t affect any of the flags, affect only some of them, or may leave them undefined.\nHere is a summary of previous instructions:\n\n\n\n\n\n\n\nInstructions\nFlags\n\n\n\n\nTransfer instructions (such as MOV, XCHG)\nNone\n\n\nADD and SUB\nAll flags\n\n\nINC and DEC\nAll flags except CF\n\n\nNEG\nAll flags (remember NEG = subtracting operand from zero)"
  },
  {
    "objectID": "lectures/lec03.html#multiplication-and-division",
    "href": "lectures/lec03.html#multiplication-and-division",
    "title": "Lecture 3: Binary Arithmetic, Logic and Addressing",
    "section": "Multiplication and Division",
    "text": "Multiplication and Division\n\nTerms\n\nWhen multiplying two numbers, the first number is multiplicand, the second number is multiplier and the result is product.\nIf the size of multiplicand is n-bit and the size of multiplier is m-bit, then the size of product is at most (n+m)-bit.\nWhen dividing two numbers, the first number is dividend, the second number is divisor, and the result is quotient. So, the dividend is the number that is divided by the divisor. The number left behind after the division is called the remainder.\n\n\n\nMUL Instruction\n\n\n\n\n\n\nSyntax\n\n\n\n        MUL     &lt;multiplier&gt;\n\n\n\nThis is the unsigned version of multiplication\nThe multiplier can be either mem or reg.\nThere are three formats depending on the size of multiplier (in 32-bit mode):\n\n\n\nMultiplier\nMultiplicand\nProduct\n\n\n\n\nreg/mem8\nAL\nAX\n\n\nreg/mem16\nAX\nDX:AX\n\n\nreg/mem32\nEAX\nEDX:EAX\n\n\nimm\nNOT ALLOWED\n\n\n\n\n\n\nFlags Affected\nThe OF and CF flags are set to 0 if the upper half of the result is 0; otherwise, they are set to 1. The SF, ZF, AF, and PF flags are undefined.\n\n\nExample\n\n\n\n\nIMUL Instruction\n\n\n\n\n\n\nSyntax\n\n\n\n        IMUL      &lt;source&gt;\n        IMUL      &lt;destination&gt;, &lt;source&gt;\n        IMUL      &lt;destination&gt;, &lt;source1&gt;, &lt;source2&gt;\n\n\n\nSingle-Operand Form\n\nThis form is identical to that used by the MUL instruction.\n\n\n\nTwo-Operand Form\n\nThe destination operand is multiplied by the source operand. The product is truncated and stored in the destination operand.\nThe destination operand must be register (either reg16 or reg32 only)\nThe valid formats are\n      IMUL    reg16, reg/mem16\n      IMUL    reg16, imm8\n      IMUL    reg16, imm16\n\n      IMUL    reg32, reg/mem32\n      IMUL    reg32, imm8\n      IMUL    reg32, imm32\n\n\n\nThree-Operand Form\n\nThe first source operand is multiplied by the second operand. The product is truncated and stored in the destination operand\nThe destination operand must be register (either reg16 or reg32). The first operand must be a register or memory with same size as the destination operand. The second operand must be immediate operand\nThe valid formats are:\n      IMUL    reg16, reg/mem16, imm8\n      IMUL    reg16, reg/mem16, imm16\n\n      IMUL    reg32, reg/mem32, imm8\n      IMUL    reg32, reg/mem32, imm32\n\n\n\nFlags Affected\n\nFor the one operand form of the instruction, the CF and OF flags are set when significant bits are carried into the upper half of the result and cleared when the result fits exactly in the lower half of the result.\nFor the two- and three-operand forms of the instruction, the CF and OF flags are set when the result must be truncated to fit in the destination operand size and cleared when the result fits exactly in the destination operand size.\nThe SF, ZF, AF, and PF flags are undefined.\n\n\n\n\n\n\n\nRemember\n\n\n\nWith the two- and three- operand forms, the result is truncated to the length of the destination before it is stored in the destination register. Because of this truncation, the CF or OF flag should be tested to ensure that no significant bits are lost.\n\n\n\n\nExamples\n\nExample 6  \n        section .data\nvarW    dw    4\nvarDW   dd    4\n\n        section .text\n        mov     ax, -16       ; AX = -16\n        mov     bx, 2         ; BX = 2\n        \n        imul    bx, ax        ; BX = -32\n        imul    bx, 2         ; BX = -64\n        imul    bx, [varW]    ; BX = -256\n        \n        mov     eax, -16\n        mov     ebx, 2\n        \n        imul    ebx, eax      ; EBX = -32\n        imul    ebx, 2        ; EBX = -64\n        imul    ebx, [varDW]  ; EBX = -256\n\n\nExample 7 Translate y = x * 7 to Assembly, assuming that x and y are declared as singed integer.\n        mov   eax, [x]\n        imul  eax, 7          ; eax = eax * 7 \n        mov   [y], eax\nOr\n        mov   eax, [x]\n        mov   ebx, 7\n        imul   ebx            ; eax = eax * ebx\n        mov   [y], eax\nOr\n        imul  eax, [x], 7 \n        mov   [y], eax\n\n\n\n\nDIV Instruction\n\n\n\n\n\n\nSyntax\n\n\n\n        DIV     &lt;divisor&gt;\n\n\n\nThis the unsigned version of division\nThere are three formats depending on the size of divisor (in 32-bit mode):\n\n\n\nDivisor\nDividend\nQuotient\nRemainder\n\n\n\n\nreg/mem8\nAX\nAL\nAH\n\n\nreg/mem16\nDX:AX\nAX\nDX\n\n\nreg/mem32\nEDX:EAX\nEAX\nEDX\n\n\nimmediate\nNOT ALLOWED\n\n\n\n\n\n\n\n\n\n\n\nRemember\n\n\n\nIf you did not set the upper half of the dividend, don’t forget to clear it using one of the following instructions:\n        xor   ax, ax\n        mov   ah, 0\n        sub   edx, edx\n\n\n\n\nFlags Affected\nThe CF, OF, SF, ZF, AF, and PF flags are undefined.\n\n\n\nIDIV Instruction\n\nThis is the signed version of division\nIt has the same syntax as DIV\nIf \\(q = a / b\\) where \\(q\\) is the quotient, \\(a\\) is the dividend, and \\(b\\) is divisor, then \\(a = q*b + r\\)\nThe sign of the remainder is always the same as the sign of the dividend\nIf the divisor is \\(0\\), an interrupt called #DE is generated to terminate the program.\n\n\n\n\n\n\n\nRemember\n\n\n\nThe dividend must be sign-extended before the division takes place. As such, x86 architecture provides CBW, CWD, and CDQ to sign extend the dividend.\n\n\n\nCBW Instruction\n\nConvert Byte to Word. This instruction requires no operand.\nImpact: If MSB of AL is 1, then AH = 0xFF, otherwise AH = 0.\n\n\n\nCWD Instruction\n\nConvert Word to Doubleword. This instruction requires no operand.\nImpact: If MSB of AX is 1, then DX = 0xFFFF, otherwise DX = 0.\n\n\n\nCDQ Instruction\n\nConvert Doubleword to Quadword. This instruction requires no operand.\nImpact: If MSB of EAX is 1, then EDX = 0xFFFF-FFFF, otherwise EDX = 0.\n\n\nExample 8  \n        mov     al, 125     ; dividend = AL = 125\n        cbw                 ; AH = 0\n        mov     bl, 2       ; BL = 2\n        div     bl          ; AL =125/2=62=3Dh, AH = 01h\n        \n        mov     al, -125    ; AL = -125 = 83h\n        cbw                 ; AX = FF83h\n        mov     bl, 2\n        idiv    bl          ; AL = -125/2 = -62 = 0C2h, AH = -1 = 0FFh\n        \n        mov     dx, 0       ; clear dividend, high\n        mov     ax, 8003h   ; dividend, low\n        mov     cx, 100h    ; divisor\n        div     cx          ; AX = 0080h, DX = 0003h\n\nIn the remaining examples, we are going to translate from high-level language to assembly language. All variables are 32-bit signed integers\n\nExample 9  \n      f = 9/5*c + 32;\n        mov     eax, [c]    ; EAX = c\n        imul    eax, 9      ; EAX = 9 * c\n        mov     ebx, 5      ; EBX = 5 (divisor)\n        cdq                 ; Sign-extend EAX to EDX\n        idiv    ebx         ; EAX = EAX / EBX\n        mov     [f], eax    ; f = EAX\n\n\nExample 10  \n      v4 = (v1 * 5) / (v2 - 3);\n        mov   eax, [v1]     ; EAX = v1\n        imul  eax, 5        ; EAX = EAX * 5\n        mov   ebx, [v2]     ; EBX = v2\n        sub   ebx, 3        ; EBX = v2 - 3\n        cdq                 ; Sign-extend EAX to EDX\n        idiv  ebx           ; EAX = EAX / EDX\n        mov   [v4], eax     ; v4 = EAX\n\n\nExample 11  \n      v4 = -v1 * 5/(-v2 % v3) \n        mov   eax, [v1]     ; EAX = v1\n        neg   eax           ; EAX = -v1\n        imul  ecx, eax, 5   ; ECX = -v1 * 5\n        \n        mov   eax, [v2]     ; EAX = v2\n        neg   eax           ; EAX = -v2\n        mov   ebx, [v3]     ; EBX = v3\n        cdq                 ; sign-extend EAX to EDX\n        idiv  ebx           ; EAX = EAX / EBX, Rem = EDX\n        \n        mov   eax, ecx      ; Set EAX = ECX (enumerator)\n        mov   ebx, edx      ; Set EBX = EDX (denominator)\n        cdq\n        idiv  ebx           ; EAX = EAX / EBX\n        \n        mov   [v4], eax     ; v4 = EAX"
  },
  {
    "objectID": "lectures/lec03.html#logic-instructions",
    "href": "lectures/lec03.html#logic-instructions",
    "title": "Lecture 3: Binary Arithmetic, Logic and Addressing",
    "section": "Logic Instructions",
    "text": "Logic Instructions\n\nThe Intel instruction set contains the AND, OR, XOR, NOT, and many more instructions , which directly implement boolean operations on binary bits.\n\n\n\n\n\n\n\nSyntax\n\n\n\n        AND     &lt;destination&gt;, &lt;source&gt;\n        OR      &lt;destination&gt;, &lt;source&gt;\n        XOR     &lt;destination&gt;, &lt;source&gt;\n        NOT     &lt;destination&gt;\n\n\n\nThe following table describes the operation of each instruction\n\n\n\n\n\n\n\nInstruction\nDescription\n\n\n\n\nAND\nBitwise logical AND operation between a source operand and a destination operand\n\n\nOR\nBitwise logical OR operation between a source operand and a destination operand\n\n\nXOR\nBitwise logical exclusive-OR operation between a source operand and a destination operand\n\n\nNOT\nBitwise NOT operation on a destination operand\n\n\n\n\n\n\n\n\n\n\nRules\n\n\n\n\nBoth operands must be the same size\nBoth operands cannot be memory operands\nThe instruction pointer register (EIP, RIP) cannot be a destination operand\n\n\n\nThe following operand types are permitted for these instructions:\n        and   reg, reg\n        and   reg, mem\n        and   reg, imm\n        and   mem, reg\n        and   mem, imm\n        not   reg\n        not   mem\n\nFlags Affected\n\nThe OF and CF are cleared.\nThe SF, ZF, and PF are set according to the result.\nThe state of AF is undefined.\n\n\n\nImplementations\n\nClearing/Masking Bits\n\nThe AND instruction allows us to clear 1 or more bits in an operand without affecting other bits. This technique is called bit masking.\nTo clear a bit (or more), use AND with a mask that has a 0 in the position which is to be cleared. All other positions in the mask contain 1.\nFor example, suppose we have the bit string \\(1110\\,0110\\) and we want to clear bit 2 (change it to 0). We can use mask \\(1111\\,1011_2\\) as follows:\n        mov     AL, 1110_0110b      ; bit string\n        and     AL, 1111_1011b      ; AL=1110 0010\n\n\n\nSetting Bits\n\nThe OR instruction allows us to set 1 or more bits in an operand without affecting any other bits.\nTo set a bit (or more), use OR with a mask that has 1 in the position which is to be set. All other positions in the mask contain 0.\nThe following code:\n        or      AL, 0000_0100b    ; set bit 2\nwill set bit at position 2 to 1 and leave other bits unchanged.\n\n\n\nToggling Bits\n\nWe can toggle or switch the value of individual bits from 1 to 0 or vice versa.\nTo toggle a bit, use XOR with a mask that has 1 in the position which is to be toggled. All other positions in the mask contain 0.\nConsider the following example\n\n\\[\n\\begin{array}{c*{9}{@{\\,}c}}\n  \\text{Original Value}     & =  & 1 & 0 & 0 & 1 & 0 & 1 & 1 & 0 \\\\\n  \\text{  XOR'ed Value}     & =  & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\\\ \\hline\n  \\text{ Toggled Value}     & =   & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1\n\\end{array}\n\\]\n\n\nTesting a Bit\n\nTo test a bit, use AND with a mask that has 1 in the position which is to be tested. All other positions in the mask contain 0.\nExample, suppose we have the bit string \\(1110\\,0110\\) and we want to test bit 5 (check its value). We can use mask \\(0010\\;0000_2\\) and the AND:\n        mov     AL, 1110_0110b    ; our bit string\n        and     AL, 0010_0000b    ; The result = 0010 0000\nSince bit 5 was set, the result is a nonzero value. However, suppose we want to test bit 4. We use mask \\(0001\\;0000\\) and the AND operation:\n        mov     AL, 1110_0110b    ; our bit string\n        and     AL, 0001_0000b    ; The result = 0000 0000\nSince bit 4 was not set, the result is a zero value.\nSo after the AND, we need to test the result; if the result is nonzero, the bit is set, otherwise it is not."
  },
  {
    "objectID": "lectures/lec03.html#indirect-addressing-modes",
    "href": "lectures/lec03.html#indirect-addressing-modes",
    "title": "Lecture 3: Binary Arithmetic, Logic and Addressing",
    "section": "Indirect Addressing Modes",
    "text": "Indirect Addressing Modes\n\nMemory locations (where the objects are located) can be specified:\n\nDirectly as static value (also known as displacement)\nIndirectly through an address computation made up of one or more of the following components:\n\nDisplacement\nBase\nIndex\nScale-Factor\n\n\nThe offset address which results from adding these components is called an effective address.\n\nIn the following section, we consider the following data definition\n        section .data\nv1      db      50, 62\narrX    dw      1, 2, 3, 4, 5\nmatr    dd      10, 11, 12, 13\n        dd      20, 21, 22, 23\n\nDisplacement Addressing Mode\n\nA displacement is 8-, 16-, or 32-bit constant value or expression\nDisplacement alone represents a direct offset to the operand.\nThe syntax is:\n\n\n\n\n\n\n        [ &lt;disp32&gt; ]\nwhere disp32 is 32-bit displacement value\n\n\n\nExample\n        mov   al, [v1]        ; AL = 50\n        add   al, [v1 + 1]    ; AL = 50 + 62 = 112\n\n\n\nBase Addressing Mode\n\nBase alone represents an indirect offset to the operand.\nIn this mode, the offset address is contained in a general purpose register. We say that the register acts as a pointer to the memory location.\nThe syntax for 32-bit architecture is:\n\n\n\n\n\n\n        [ &lt;reg32&gt; ]\n\n\n\nExample:\n        mov     esi, arrX     ; ESI points to the 1st element in arrX\n        mov     ax, 0         ; set sum to zero\n        add     ax, [esi]     ; add arrX[0] to sum, AX = 1\n        add     esi, 2        ; move pointer to next element\n        add     ax, [esi]     ; add arrX[1] to sum, AX = 1+2 = 3\n        add     esi, 2        ; move pointer to next element\n        add     ax, [esi]     ; add arrX[2] to sum, AX = 3+3 = 6\n\n\n\nBase + Displacement Addressing Mode\n\nA base register and a displacement can be used together to access a field of a record. The base register holds the address of the beginning of the record, while the displacement holds a static offset to the field\nThis mode is specially useful when we need to access parameters in a procedure activation record. We will elaborate this mode when we discuss procedures.\nThe syntax is\n\n\n\n\n\n\n        [ &lt;reg32&gt; + &lt;disp&gt; ]\n\n        [ &lt;reg32&gt; - &lt;disp&gt; ]\n\n\n\nExample:\n        mov   esi, v1       ; esi points to v1\n        mov   al, [esi + 0] ; AL = 50\n        mov   bl, [esi + 1] ; BL = 62 \n\n\n\nIndex Addressing Mode\n\nIn this mode, there are two forms:\n        [index + displacement]\n\n        [index*scale + displacement]\nThe index is a general purpose register except ESP\nFor 32-bit mode, the syntax:\n\n\n\n\n\n\n        [ &lt;reg32&gt; + &lt;disp32&gt; ]\n\n        [ &lt;reg32&gt;*&lt;scale&gt; + &lt;disp32&gt; ]\nwhere &lt;scale&gt; can be either 1, 2, 4, or 8\n\n\n\nIn index mode, the displacement locates the beginning of an array, the index register holds the subscript of the desired array element, and scale represents the data type.\nFor example, arrX[3] can be translated to assembly as [ecx*2 + arrX] where the register ECX holds the value 3.\nExample\n        mov     ax, 0               ; set sum to zero\n        mov     esi, 0              ; set array index to 0\n        add     ax, [esi*2 + arrX]  ; add arrX[0] to sum, AX = 1\n        inc     esi                 ; increment the index by 1\n        add     ax, [esi*2 + arrX]  ; add arrX[1] to sum, AX = 1+2 = 3\n        inc     esi                 ; increment the index by 1 \n        add     ax, [esi*2 + arrX]  ; add arrX[2] to sum, AX = 3+3 = 6\n\n\n\nBase + Index Addressing Mode\n\nIn this mode, the base register holds the address of a dynamic array, while the index register holds offset address or subscript index.\n\nIn 2D arrays, the base register holds the address of the beginning of a row. The index register holds the column’s subscription\n\nThe syntax is:\n\n\n\n\n\n\n        [ &lt;base&gt; + &lt;index&gt; ]\n\n        [ &lt;base&gt; + &lt;index&gt;*&lt;scale&gt; ]\nwhere &lt;base&gt; and &lt;index&gt; are reg32.\n\n\n\n\n\n\nBase + Index + Displacement Addressing Mode\n\nThis mode is a combination of previous modes\nThis mode is suitable for traversing array of records.\n\n\n\nSummary\nThe following diagram, adopted from Intel manual summarizes the memory addressing modes:\n\n\n\nOffset (or Effective Address) Computation"
  },
  {
    "objectID": "lectures/lec01.html",
    "href": "lectures/lec01.html",
    "title": "Lecture 1: Basic Concepts",
    "section": "",
    "text": "Revise the following representations:\n\nBinary integers\n\nUnsigned binary integers:\n\nTranslating unsigned binary integer to decimal\nTranslating unsigned decimal to binary\n\nSigned binary integers:\n\n1’s complement representation\n2’s complement representation\n\n\nHexadecimal integers\n\nHexadecimal 2’s complement\nTranslating binary integer to hexadecimal and vice versa.\nTranslating hexadecimal integer to decimal and vice versa.\n\n\n\n\n\n\n\n\n\nExample\n\n\n\n\nConvert the following number \\((1100101)_2\\) to decimal.\n\\[\\begin{align*}\n     1100101_2 &= 1\\times2^0 + 0\\times2^1 + 1\\times2^2 + 0\\times2^3 + 0\\times2^4 + 1\\times2^5 + 1\\times2^6 \\\\\n     &= 1+4+32+64=101_{10}\n\\end{align*}\\]\nConvert the following number \\((A13)_{16}\\) to decimal.\n\\[\\begin{align*}\n     A13_{16} &= 3\\times16^0 + 1\\times16^1 + 10\\times16^2 \\\\\n     &= 3 + 16 + 2560 = 2579_{10}\n\\end{align*}\\]\nConvert the following number \\(-14_{10}\\) to one-word binary.\n\\[\\begin{align*}\n     14_{10} = 8 + 4 + 2 = 1110_2 &= 0000\\; 0000\\; 0000\\; 1110_2 \\\\\n     Neg &= 1111\\; 1111\\; 1111\\; 0001_2 \\\\\n     +1 &= 1111\\; 1111\\; 1111\\; 0010_2\n\\end{align*}\\]\n\\(\\therefore -14_{10} = 1111\\;1111\\;1111\\;0010_2\\)\nConvert the following number \\(-14_{10}\\) to one-word hexadecimal\n\\(-14_{10}\\) = FFF216\n\n\n\n\nBinary-Coded Decimal (BCD) Numbers:\n\nEvery decimal digit is represented by 4 binary bits, from 0000 to 1001.\nTwo representations: Unpacked BCD and packed BCD.\nIn unpacked BCD, one decimal digit is encoded in each binary byte. While, in packed BCD, two decimal digits are encoded in each binary byte.\n\n\n\n\nDecimal Number\nUnpacked (in Hex)\nPacked (in Hex)\n\n\n\n\n\\((176)_{10}\\)\n01 07 06\n01 76\n\n\n\nInteger storage sizes\n\n\n\nStorage Name\nSize in BYTE\nsize in BITS\n\n\n\n\nbyte\n1\n8\n\n\nword\n2\n16\n\n\ndoubleword\n4\n32\n\n\nquadword\n8\n64\n\n\n\n\n\n\n\n\nCharacters are represented by using character set, which is one-to-one mapping of characters to integers.\n\n\n\nCharacter set\nCharacter size\n\n\n\n\nASCII\n7 bits\n\n\nANSI\n8 bits\n\n\nUTF-8\n8 bits\n\n\nUTF-16\n16 bits\n\n\nUTF-32\n32 bits\n\n\n\nUTF stadnds for Unicode Transformation Format.\nASCII Strings\n\nStrings are stored in memory as a succession of bytes containing ASCII codes. For example, \"ABC123\" is stored in memory as 41h, 42h, 43h, 31h, 32h, and 33h.\nA null-terminated string is a string of characters followed by a single byte containing zero (NULL). For example, the null-terminated string \"ABC123\" is stored in memory as 41h, 42h, 43h, 31h, 32h, 33h, and 00h.\n\n\n\n\n\n\nReal numbers are represented using the binary representation of IEEE 754 Standard.\nThe representation in memory:\n\n\n\nMemory layout for floating point\n\n\nwhere s is the sign bit, e is the exponent, and f is the significand.\n\\(x = (-1)^s (1 + f) \\times 2^m\\), where \\(m = e - bias\\)\nFloating-point Types:\n\n\n\nType\nSize\nExponent\nFraction\nBias\n\n\n\n\nSingle-precision\n32\n8\n23\n127\n\n\nDouble-precision\n64\n11\n52\n1023\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n\nConvert \\(-11.375_{10}\\) to single-precision binary representation?\n\\(11_{10} = (1011)_2\\)\n\\(0.375_{10} = (2^{-2} + 2^{-3}) = 0.25 + 0.125 = (.011)_2\\)\n\n\\(\\therefore 11.375_{10} = (1011.011)_2 = 1.011011 \\times 2^{+3}\\)\nTherefore,\ns = 1 (sign is enabled)\ne = 3 + 127 = 130 = (1000 0010)2\nf = (011011)2\nThe representation is: \\(1100\\,\\,0001 \\,\\, 0011 \\,\\, 0110 \\,\\, 0000 \\,\\, 0000 \\,\\, 0000 \\,\\, 0000_2\\) = C136000016\n\n\n\n\n\n\nConversion\n\n\n\n\n\n\nFloating-point representation is NOT recommended to store money amount. In languages such as Java or C++, floating point values have certain rounding characteristics that make it difficult to compare them for equality. The common example to illustrate the problem is 0.1 + 0.2 != 0.3.\nSome applications use BCD (such as BigInteger class in the Java class library)."
  },
  {
    "objectID": "lectures/lec01.html#data-representation",
    "href": "lectures/lec01.html#data-representation",
    "title": "Lecture 1: Basic Concepts",
    "section": "",
    "text": "Revise the following representations:\n\nBinary integers\n\nUnsigned binary integers:\n\nTranslating unsigned binary integer to decimal\nTranslating unsigned decimal to binary\n\nSigned binary integers:\n\n1’s complement representation\n2’s complement representation\n\n\nHexadecimal integers\n\nHexadecimal 2’s complement\nTranslating binary integer to hexadecimal and vice versa.\nTranslating hexadecimal integer to decimal and vice versa.\n\n\n\n\n\n\n\n\n\nExample\n\n\n\n\nConvert the following number \\((1100101)_2\\) to decimal.\n\\[\\begin{align*}\n     1100101_2 &= 1\\times2^0 + 0\\times2^1 + 1\\times2^2 + 0\\times2^3 + 0\\times2^4 + 1\\times2^5 + 1\\times2^6 \\\\\n     &= 1+4+32+64=101_{10}\n\\end{align*}\\]\nConvert the following number \\((A13)_{16}\\) to decimal.\n\\[\\begin{align*}\n     A13_{16} &= 3\\times16^0 + 1\\times16^1 + 10\\times16^2 \\\\\n     &= 3 + 16 + 2560 = 2579_{10}\n\\end{align*}\\]\nConvert the following number \\(-14_{10}\\) to one-word binary.\n\\[\\begin{align*}\n     14_{10} = 8 + 4 + 2 = 1110_2 &= 0000\\; 0000\\; 0000\\; 1110_2 \\\\\n     Neg &= 1111\\; 1111\\; 1111\\; 0001_2 \\\\\n     +1 &= 1111\\; 1111\\; 1111\\; 0010_2\n\\end{align*}\\]\n\\(\\therefore -14_{10} = 1111\\;1111\\;1111\\;0010_2\\)\nConvert the following number \\(-14_{10}\\) to one-word hexadecimal\n\\(-14_{10}\\) = FFF216\n\n\n\n\nBinary-Coded Decimal (BCD) Numbers:\n\nEvery decimal digit is represented by 4 binary bits, from 0000 to 1001.\nTwo representations: Unpacked BCD and packed BCD.\nIn unpacked BCD, one decimal digit is encoded in each binary byte. While, in packed BCD, two decimal digits are encoded in each binary byte.\n\n\n\n\nDecimal Number\nUnpacked (in Hex)\nPacked (in Hex)\n\n\n\n\n\\((176)_{10}\\)\n01 07 06\n01 76\n\n\n\nInteger storage sizes\n\n\n\nStorage Name\nSize in BYTE\nsize in BITS\n\n\n\n\nbyte\n1\n8\n\n\nword\n2\n16\n\n\ndoubleword\n4\n32\n\n\nquadword\n8\n64\n\n\n\n\n\n\n\n\nCharacters are represented by using character set, which is one-to-one mapping of characters to integers.\n\n\n\nCharacter set\nCharacter size\n\n\n\n\nASCII\n7 bits\n\n\nANSI\n8 bits\n\n\nUTF-8\n8 bits\n\n\nUTF-16\n16 bits\n\n\nUTF-32\n32 bits\n\n\n\nUTF stadnds for Unicode Transformation Format.\nASCII Strings\n\nStrings are stored in memory as a succession of bytes containing ASCII codes. For example, \"ABC123\" is stored in memory as 41h, 42h, 43h, 31h, 32h, and 33h.\nA null-terminated string is a string of characters followed by a single byte containing zero (NULL). For example, the null-terminated string \"ABC123\" is stored in memory as 41h, 42h, 43h, 31h, 32h, 33h, and 00h.\n\n\n\n\n\n\nReal numbers are represented using the binary representation of IEEE 754 Standard.\nThe representation in memory:\n\n\n\nMemory layout for floating point\n\n\nwhere s is the sign bit, e is the exponent, and f is the significand.\n\\(x = (-1)^s (1 + f) \\times 2^m\\), where \\(m = e - bias\\)\nFloating-point Types:\n\n\n\nType\nSize\nExponent\nFraction\nBias\n\n\n\n\nSingle-precision\n32\n8\n23\n127\n\n\nDouble-precision\n64\n11\n52\n1023\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n\nConvert \\(-11.375_{10}\\) to single-precision binary representation?\n\\(11_{10} = (1011)_2\\)\n\\(0.375_{10} = (2^{-2} + 2^{-3}) = 0.25 + 0.125 = (.011)_2\\)\n\n\\(\\therefore 11.375_{10} = (1011.011)_2 = 1.011011 \\times 2^{+3}\\)\nTherefore,\ns = 1 (sign is enabled)\ne = 3 + 127 = 130 = (1000 0010)2\nf = (011011)2\nThe representation is: \\(1100\\,\\,0001 \\,\\, 0011 \\,\\, 0110 \\,\\, 0000 \\,\\, 0000 \\,\\, 0000 \\,\\, 0000_2\\) = C136000016\n\n\n\n\n\n\nConversion\n\n\n\n\n\n\nFloating-point representation is NOT recommended to store money amount. In languages such as Java or C++, floating point values have certain rounding characteristics that make it difficult to compare them for equality. The common example to illustrate the problem is 0.1 + 0.2 != 0.3.\nSome applications use BCD (such as BigInteger class in the Java class library)."
  },
  {
    "objectID": "lectures/lec01.html#intel-microprocessors",
    "href": "lectures/lec01.html#intel-microprocessors",
    "title": "Lecture 1: Basic Concepts",
    "section": "Intel Microprocessors",
    "text": "Intel Microprocessors\n\nConventionally, Intel microprocessors are known as x86 processors.\nx86 microprocessors are divided into three families: x86-16, x86-32 and x86-64.\nAll Intel microprocessors are byte addressable.\nIn 1974, Intel has announced 8080 CPU: 8-bit CPU (2Mhz) and 16-bit address bus (64KB).\nIn 1978, 8086 CPU has been introduced with 16-bit CPU (16-bit registers and 16-bit external data bus) and 20-bit address bus with CPU speed ranging from 5MHz to 10MHz.\n\nMemory addresses start from 00000H to 0FFFFFH (1MB)\nThe address space is divided into segments. A segment is a region of memory that begins on a paragraph boundary and extends for some number of bytes (&lt;= 64K).\nA paragraph is a measure of memory equal to 16 bytes.\n8086 CPUs have four 16-bit segment registers: CS, DS, SS, and ES.\nThe physical address is constructed by two registers: segment address:offset address.\n\nIn 1982, Intel 286 introduced protected mode operation with four privilege levels. The address bus was 24-bit providing 16MB physical memory.\nThe Intel 386 (1985) was the first 32-bit CPU (80386 CPUs) with 32-bit address bus (addressable up to 4G).\n\n80386 CPUs are backward compatible with 8086 CPUs and hence the term x86 family.\nIn addition, it supports for :\n\nA segmented–memory model and a flat memory model.\nPaging, with a fixed 4KB page size providing a method for virtual memory management.\nSupport for 3-stage instruction pipeline (Fetch-Decode-Execute) .\n\n\nIntel 486 (1989) processors are all based on IA-32 architecture with additional support for parallel execution capabilities (ILP):\n\nIt supports 5-stage instruction pipeline.\nIt supports 8KB on-chip L1-cache (using Write-through policy)\nIt has an integrated x87 FPU\n\nIntel Pentium Processor (1993), also known unofficially as P5 or Intel 586, marked a significant advancement in microarchitecture technology. It supports:\n\nSuperscalar architecture, which allows to execute more than one instruction per clock cycle\n8KB L1 cache devoted for code and another 8KB L1 cache devoted for data.\nIntroduced MMX technology, which uses the single-instruction, multiple data (SIMD) execution model with 64-bit registers.\n\nIntel P6 Family (1995-1999), which includes Intel Pentium Pro, Intel Pentium II and III, and Intel Celeron, was introduced.\nIntel 64 architecture was introduced in the Intel Pentium 4 Processor (Extreme Edition) in 2005.\nThe 2010 Intel processor family (First Generation) spans Intel Core i7, i5 and i3 processors. In 2017, Intel Core i9 was introduced. The current generation is 14. Intel currently has several sub-families:\n\nIntel Xeon Processors for data centers and workstations.\nIntel Core Ultra Processors for AI and immersive graphics.\nIntel Core Processors for laptops and desktops.\nIntel Atom Processors for mobile and IoT devices"
  },
  {
    "objectID": "lectures/lec01.html#ia-32-basic-execution-environment",
    "href": "lectures/lec01.html#ia-32-basic-execution-environment",
    "title": "Lecture 1: Basic Concepts",
    "section": "IA-32 Basic Execution Environment",
    "text": "IA-32 Basic Execution Environment\nAs an assembly programmer, you should know the execution environment either for IA-32 or Intel 64 processor.\nAny program running on an IA-32 processor is given a set of resources for executing instructions and for storing code, data and state information.\nThe basic execution environment includes memory (the address space), general purpose data registers, segment registers, the flags register, and the instruction pointer register.\n\nModes of Operation in IA-32\nModes of operation define the memory layout and how a program can address memory (using registers). It also determines which instructions are accessible.\nIA-32 processors have three primary modes of operation:\n\nProtected mode, in which programs are given separate memory areas named segments, and the processor prevents programs from referencing memory outside their assigned segments. This is the default mode.\nReal–Address mode, in which programs can access to system memory and hardware devices. OS prevents programmers to switch to this mode.\nSystem Management mode, in which it provides an OS with a mechanism for implementing functions such as power management and system security. These functions are usually implemented by computer manufacturers.\n\nA sub–mode, named virtual-8086, is a special case of protected mode, in which MS–DOS programs (real-mode software) can be executed in a safe environment.\n\nModes of Operations in Intel 64\nThe Intel 64 architecture adds IA-32e mode, which has two sub-modes:\n\ncompatibility mode, which permits legacy 16-bit and 32-bit applications to run without re-compilation under a 64-bit Operating System. Compatibility mode is similar to 32-bit protected mode.\n64-bit mode, which enables a program to access 64-bit linear address space.\n\n\n\n\nCPU Registers\n\nSegment Registers\n\nThe 8086, 8088 and and 80286 have exactly four segment registers specifically designated as holders of segment address.\nThe 80386 and later CPUs have two more that can be used in real mode.\nThe segment registers:\n\nCS, which stands for code segment\nDS, which stands for data segment\nSS, which stands for stack segment\nES, which stands for extra segment.\nFS and GS. They are both additional “extra” segments.\n\nAll segment registers are 16 bits in size, irrespective of the CPU architecture.\nSegment registers was to allow 20 bits of address space to be addressed by two 16-bit registers (in the form of segment address : offset address).\nIn IA-32 architecture, segment registers are used only by the operating system.\nThe segment registers are not used in x64 architecture.\n\n\n\nGeneral-Purpose Registers (GPRs)\n\nThe 32-bit GPRs are EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP.\nGPRs are primarily used for\n\narithmetic and logical operations.\naddress calculations.\nmemory pointers\n\nAlthough all of these registers are available for general storage of operands, ESP register holds the stack pointer and as general rule should not be used for another purpose.\n\n\n\nSome general-purpose registers have specialized uses:\n\nEAX is used for multiplication and division instructions.\nECX is automatically used as loop counter.\nESP addresses data on the stack.\nESI and EDI are used by high–speed memory transfer instructions.\nEBP is used by high–level languages to reference function parameters and local variables on the stack. It should not be used for ordinary arithmetic or data transfer.\n\n\n\n\nThe Flags Register (EFLAGS register)\n\n\nEFLAGS consists of individual binary bits that control the CPU operation or reflect the status of last executed instruction\nSome instructions test and manipulate individual flags\nA flag is set when it equals 1; it is clear when it equals 0.\nSome of the flags in the EFLAGS register can be modified directly, using special-purpose instructions.\nThe status flags (bits 0, 2, 4, 6, 7, and 11) of the EFLAGS register indicate the results of arithmetic and logical instructions, such as the AND, OR, ADD, SUB, MUL, and DIV instructions. The functions of the status flags are as follows:\n\n\n\n\n\n\n\nFlag\nDescription\n\n\n\n\nCF (bit 0)\nCarry flag. Set if an arithmetic operation generates a carry or a borrow out of the most-significant bit of the result; cleared otherwise. This flag indicates an overflow condition for unsigned-integer arithmetic. It is also used in multiple-precision arithmetic.\n\n\nPF (bit 2)\nParity flag. Set if the least-significant byte of the result contains an even number of 1 bits; cleared otherwise.\n\n\nAF (bit 4)\nAuxiliary flag. Set if an arithmetic operation generates a carry or a borrow out of bit 3 of the result; cleared otherwise. This flag is used in binary-coded decimal (BCD) arithmetic.\n\n\nZF (bit 6)\nZero flag. Set if the result is zero; cleared otherwise.\n\n\nSF (bit 7)\nSign flag. Set equal to the most-significant bit of the result, which is the sign bit of a signed integer. (0 indicates a positive value and 1 indicates a negative value.)\n\n\nOF (bit 11)\nOverflow flag. Set if the integer result is too large a positive number or too small a negative number (excluding the sign-bit) to fit in the destination operand; cleared otherwise. This flag indicates an over flow condition for signed-integer (two’s complement) arithmetic.\n\n\n\nOf these status flags, only the CF flag can be modified directly, using the STC, CLC, and CMC instructions. Also the bit instructions (BT, BTS, BTR, and BTC) copy a specified bit into the CF flag.\n\n\n\n\nAddress Space\n\nThe memory that the processor addresses on its bus is called physical memory.\nPhysical memory is organized as a sequence of 8-bit bytes. Each memory byte is assigned a unique address, called a physical address. In IA-32 architecture, physical addresses range from zero to a maximum of 232−1 (or 236−1 when Physical Address Extension PAE is enabled).\nx86 memory has three major memory models, which are:\n\nReal-mode flat model\nReal-mode segmented model\n32-bit protected-mode flat model\n64-bit long mode (will be discussed later in this course)\n\n\n\nReal-Mode Flat Model\n\nIn real-mode flat model, a program and all the data it works on must exist within a single 64KB block of memory.\nThe segment registers are all set to point to the beginning of the 64KB block of memory (The OS sets them when it loads and runs the program).\n\n\n\nReal-Mode Segmented Model\n\nYour program can still see 1MB of memory available to the CPU in real mode. However, the 20-bit address is constructed by combining the 16-bit segment address with 16-bit offset address.\n\n\n\n32-Bit Protected Mode Flat Model\n\nIn 32-bit protected mode, a program can address a linear address space of up to 4GB.\n\nEach address is 32-bit quantity including the EIP.\nThe segment registers are still exist, but controlled by the operating system. You, as programmer, neither read nor change them directly. The segment registers define where your 4GB memory space exists in physical or virtual memory."
  },
  {
    "objectID": "lectures/lec01.html#assembly-language",
    "href": "lectures/lec01.html#assembly-language",
    "title": "Lecture 1: Basic Concepts",
    "section": "Assembly Language",
    "text": "Assembly Language\n\nWhat is Assembly Language\n\nAssembly Language is the oldest programming language, bears the closest resemblance to native machine language. Hence, assembly language is a low-level programming language.\nAssembly language for x86 (the focus of this course) means programming on microprocessors compatible with Intel and AMD processors running under Windows, Linux, Unix, etc.\n\n\n\nMachine Language\n\nA CPU can only execute machine instructions. These instructions are bit strings. The following is a short program written in machine language for the IBM PC:\n\n\n\nMachine Instruction\nDescription\n\n\n\n\n10100001 00000000 00000000\nMove content of memory word 0 to AX\n\n\n00000101 00000100 00000000\nAdd 4 to AX\n\n\n10100011 00000000 00000000\nMove content of AX to memory word 0\n\n\n\nA more convenient language to use is assembly language. It uses symbolic names to represent operations, registers, and/or memory location. If memory location 0 is symbolized by A, the preceding program can be expressed like this in assembly language:\nmov   ax, [A]   ; move content of A to AX\nadd   ax, 4     ; add 4 to the content of AX\nmov   [A], ax   ; move content of AX to A\n\n\n\nAssembly Language Compared to High-Level Language\nThe following assignment statement (C/C++):\nint y = (x + 10) * 3;\ncan be translated to Assembly language as follows:\nmov   eax, [x]    ; move content of x to EAX register\nadd   eax, 10     ; Add 10 to EAX\nmov   ebx, 3      ; Let EBX = 3\nimul  ebx         ; perform EAX = EAX * EBX\nmov   [y], eax    ; store the result into Y\n\n\nIs Assembly Language Portable?\n\nA language whose source programs can be compiled and run on a wide variety of computer systems is said to be portable.\n\nJava is portable, compiled programs run nearly on any computer\nC++ is portable, can compile and run on any computer if standard library is used\n\nAssembly is NOT portable, because it is designed for a specific processor family and operating system.\n\n\n\nWhy Learning Assembly Language\n\nEfficiency in terms of size and time, because assembly language is so close to machine language\nWriting system programs (Operating system, Embedded programming, device driver, etc)\n\n\n\nThe Assembler\n\nUnfortunately, there is no standardization for x86 assembly language like other high-level languages, such as C and C++\nThe assembly language mainly depends on\n\nthe instruction set (ISA) of a microprocessor, and\na utility program called assembler.\n\n\n\n\nAn assembler: is a utility program that converts source code programs from assembly language into machine language (known as object source file).\nThere are many different assemblers out there for x86 architecture:\n\nMASM (Microsoft Macro Assembler)\nNASM (Netwide Assembler)\nTASM (Turbo Assembler)\nGAS (GNU Assembler)\n… and many more\n\nAll x86 assemblers use radically different assembly language\n\nThey agree on the instruction set (Like MOV, ADD, SUB, etc)\nThey differ on how the registers are used and how the operands are addressed.\n\nThis course will consider NASM assembler.\n\n\nNASM Assembler\n\nThe Netwide Assembler, NASM, is an IA-32 and Intel 64 assembler designed for portability and modularity\nNASM is a free cross-platform x86 assembler which supports all common x86 operating systems: Windows, Linux, MacOS X, Unix, etc.\nNASM provides a simple syntax that closely resembles Intel’s assembly language while offering compatibility with a variety of output formats, such as ELF, COFF, and Mach-O.\n\n\n\n\nProgramming Tools That You Need\n\nTo develop an assembly program, you need\n\nan assembler, which we are going to use NASM\nan editor; there are several choices\n\nVisual Studio Code\nNotepad++\nVIM under Linux\n\nA Linker: is a utility program that combines individual object files created by an assembler into a single executable program.\n(Optionally) a debugger, in case you need to debug your code.\n\n\n\nBuilding Process\n\n\n\nObject File Format\n\nCompilers and assemblers create object files containing the generated machine code and data for a source file. Linkers combine multiple object files into one binary file (known as image file or executable file). Loaders take image files and load them into memory (in order to be executed).\n\n\n\n\n\n\n\nWhat goes into object file?\n\n\n\n\nHeader information,\nRelocation table,\nSymbols,\nDebugging information, and\nof course, Machine code\n\n\n\n\nThere are many object file formats. Some you should know about include:\n\nCOFF, primary for UNIX\nWin32 and Win64, primary for Windows OS\nELF and ELF64, primary for Linux\nMacho32 and Macho64, primary for MacOS X"
  },
  {
    "objectID": "exercises/inclass03.html",
    "href": "exercises/inclass03.html",
    "title": "Exercise 3",
    "section": "",
    "text": "Consider the following code:\n        section .data\nvarA:   db      10h\n        db      20h, 30h\nvarB:   dd      405060h\nvarC:   dw      70h\n\nsection .text\n        mov     eax, [varA]\n        mov     ebx, varC\n        mov     cx, [varB + 2]\n        mov     dh, [varB – 2]\n\nAssume that the data segment starts at address 04004000h when loaded into main memory. Show the content of this data segment. You must display the locations of variables (labels), the content of each memory cell in hexadecimal notation, and memory addresses.\nWhat will be the values of EAX, EBX, CX, and DH in hexadecimal after executing the instructions in the code section?\n\nConsider the following data section (assuming $$ = 0x4004000)\n      section .data\nxarr  dd      1000h, 2000h, 3000h, 4000h\nnum   equ     ($ - xarr)\nyvar  dd      xarr\n\nWhat is the constant value of num after compilation?\nDoes num indicate the number of elements in the array xarr? If not, then modify the definition of num in order to hold the number of elements.\nWhat will be the value of EAX after executing the following instruction:\n        mov     eax, [xarr]\nWhat will be the value of EAX after executing the following instruction:\n        mov     eax, [yvar]"
  },
  {
    "objectID": "exercises/inclass01.html",
    "href": "exercises/inclass01.html",
    "title": "Exercise 1",
    "section": "",
    "text": "What is the decimal representation of each of the following unsigned binary integers?\n\n\n\n00110101\n10010110\n11001100\n\n\n\nWhat is the sum of each pair of binary integers?\n\n\n\n10101111 + 11011011\n10010111 + 11111111\n01110101 + 10101100\n\n\n\nWhat is the decimal representation of each of the following 8-bit signed binary numbers?\n\n\n\n10110101\n00101010\n11110000\n\n\n\nWhat is the decimal representation of each of the following signed binary numbers? Without calculation\n\n\n\n10000000\n11111111\n01111111\n\n\n\nWhat is the hexadecimal representation of each of the following binary numbers?\n\n\n\n0011 0101 1101 1010\n1100 1110 1010 0011\n1111 1110 1101 1011\n\n\n\nWhat is the binary representation of the following hexadecimal numbers?\n\n\n\n0126F9D4\n6ACDFA95\nF69BDC2A\n\n\n\nCalculate binary 00001101 minus 00000111.\nCalculate -126 - 3 after converting each number to 8-bit binary number."
  },
  {
    "objectID": "exercises/inclass02.html",
    "href": "exercises/inclass02.html",
    "title": "Exercise 2",
    "section": "",
    "text": "Declare four symbolic constants that represent integer 25 in decimal, binary, octal, and hexadecimal formats.\nGiven the number 456789ABh, list out its byte values in little-endian order.\nGiven the number 456789ABh, list out its byte values in big-endian order.\nDefine an array of 120 uninitialized unsigned doubleword values.\nDefine an array of byte and initialize it to the first 5 letters of the alphabet.\nDefine a 32-bit signed integer variable and initialize it with the smallest possible negative decimal value. (Hint: Refer to integer ranges in Chapter 1.)\nDefine an unsigned 16-bit integer variable named wArray and initialize it with three values of your choice.\nDefine a string variable containing the name of your favorite color. Initialize it as a null-terminated string.\nDefine an uninitialized array of 50 signed doublewords named dArray.\nDefine a string variable containing the word “TEST” repeated 500 times.\nDefine an array of 20 unsigned bytes named bArray and initialize all elements to zero.\nTell whether each of the following instructions is legal or illegal. W1 and W2 are word variables, and D1 and D2 are doubleword variables.\n\n\n\nMOV AL, BH\nMOV EAX, 1\nXCHG [W1], [D1]\nMOV EDX, [W1]"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "C404: Assembly Language",
    "section": "",
    "text": "Course summary\nThis course covers the organization and behavior of real computer systems at the assembly-language level. Topics include the mapping of statements and constructs in a high-level language onto sequences of machine instructions, as well as the internal representation of simple data types and structures. Numerical computation and subroutines are examined.\n\n\nCourse Goals\nYou will gain the following knowledge in topics related to assembly language:\n\nIntel and AMD processor architecture and programming.\nDescribe von Neumann architecture and how its components interact.\nReal-address mode and protected mode programming.\nAssembly language directives, macros, operators, and program structure.\nDemonstrate how fundamental high-level programming constructs are implemented at the machine-language level.\nUnderstand the Assembly Language’s procedures, parameter passing and stack operations.\nProgramming methodology, showing how to use assembly language to create system-level software tools and application programs.\nDiagnosing and debugging assembly language programs.\n\n\n\nTextbooks\n\n\n\n\n\n\nAssembly Language for x86\n\n\n\n\n\nAssembly Language for x86 Processors\nby Kip Irvine\nPearson 2019, 8th Edition\n\n\n\n\n\nLab Resources\nIt is quite important to try all examples in the lecture notes. You have two options:\n\nUse online compilers (Quick and easy):\n\nOneCompiler.com\n\nSee Lab(1)\n\n\n\nGrading\n\n\n\nActivity\nWeight\n\n\n\n\nLabs\n40%\n\n\nFinal Exam\n60%\n\n\n\n\n\nTentative Schedule\n\n\n\nWeek #\nTopic\nKip\nAssignment\n\n\n\n\n\nWeek 1\nBasic Concepts\nCh.1-2\n\n\n\n\nWeek 2\nAssembly Language Fundamentals\nCh.3-4\nLab(1)"
  },
  {
    "objectID": "lectures/lec02.html",
    "href": "lectures/lec02.html",
    "title": "Lecture 2: Assembly Language Fundamentals",
    "section": "",
    "text": "Let us consider the following program:\n;\n;   Adding two numbers\n;\n      global _main\n      \n      section .data\nsum   dd      0\n\n      section .code\n_main:\n      mov     eax, 5      ; let eax = 5\n      add     eax, 6      ; add 6 to eax\n      mov     [sum], eax  ; store result into sum\n      \n      ret\n\n\n\nAn assembly program consists of statements. There are three types of statements: instructions, directives, and macros.\nAn instruction is translated by the assembler into one or more bytes of object code (machine code), which will be executed at run time.\nA directive tells the assembler to perform some special tasks, such as allocating memory space for a variable or creating a procedure.\nA macro is “shorthand” for a sequence of other statements.\nBy default, assembly is not case-sensitive.\nAny statement has up to four fields, separated by at least one white space:\n[label:]     instruction   [operand(s)]   [;comment]\n\nThe four fields are displayed in the following diagram:\n\n\n\nThe layout of source lines. Blue rectangle for label; Red rectangle for either instruction or directive; Orange rectangle for operands or arguments; Green rectangle for comment\n\n\n\n\n\n\nA comment always starts with a semicolon character ; and ends with newline character, as shown as red rectangles in the following diagram:\n\nAt the top of every program, you should add a comment block that contains:\n\nThe name of the source code file,\nThe date you created the file,\nThe date you last modified the file,\nThe name of the person who wrote it,\nThe name and version of the assembler used,\nAn overview description of the what the program or library does.\nA copy of the commands used to build the file\nHere is an example:\n; -----------------------------------------------------------------\n; Source name   : addtwo.asm\n; Version       : 1.0\n; Created date  : 10/4/2020\n; Last modified : 22/8/2024\n; Author        : Khalid Elbadawi\n; Compiling     : nasm -fwin32 addtwo.asm (NASM version 2.15)\n; Description   : Store the result of 5 + 6 \n; -----------------------------------------------------------------\n\n\n\n\n\n\nGenerally, programs written in assembly language are divided into sections, which represent memory segments.\nSections are defined by the assembler directive.\nIn NASM, sections are created by using section keyword followed by the section name, such as .data, .bss, or .text\n\nThe .data section: contains data definitions of initialized data items\nThe .bss section: contains data definitions of uninitialized data items\nThe .text section: contains the actual machines instructions (i.e., the code) that make up your program\n\nIn the following diagram, the data section is enclosed by the GREEN rectangle and code (or text) section is enclosed by the RED rectangle:\n\n\n\n\n\n\nA label field is a programmer-chosen identifier. It might identify a variable, a constant, a procedure or an instruction label.\nRules for choosing an identifier are (in NASM):\n\nMust not exceed more than 247 characters\nMust start with a letter, underscore or ?.\nSubsequent characters may also be digits, @, #, $, or dot.\nMust not be a reserved word\n\nIn general, it’s good idea to use descriptive names for identifiers.\nLabels, in NASM, are case sensitive.\n\n\n\n\n\nThere are different types of reserved words:\n\nInstruction mnemonics (the Instruction Set), such as ADD, SUB, MOV.\nRegister names, such as EAX, AX, AL, ch\nDirectives, such as DB, DWORD.\nOperand attributes, such FAR, NEAR, BYTE.\nOperators used in constant expressions.\n\nReserved words are NOT case sensitives\n\n\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\n\n[{+|-}] digits [radix]\n\n\nwhere radix can be\n\nh (hexadecimal),\no or q (octal),\nd (decimal), and\nb (binary)\n\n\n\n\n\n\n\nExample\n\n\n\n\n\n\nInteger constants\nBase\n\n\n\n\n198\ndecimal\n\n\n0200\ndecimal\n\n\n-2d\ndecimal\n\n\n+101b\nbinary\n\n\n1100_0001b\nbinary\n\n\n107o\noctal\n\n\n107q\nstill octal (more readable)\n\n\n23bh\nhexadecimal\n\n\n23Bh\nhexadecimal\n\n\n0ah\nhexadecimal\n\n\n0xC8\nhexadecimal (C syntax)\n\n\n\n\n\n\n\n\n\nCharacters and character string must be enclosed in single quotes, double quotes or back quotes.\n\n\"A\" or \"Hello\"\n'A' or 'Hello'\n`A` or `Hello`\n\nCharacters are stored in contiguous memory and translated into their ASCII codes by the assemblers, so there is no difference between using \"A\" and 41h in an assembly program.\n\n\n\nCharacter/String Literal\nValue in Hex\n\n\n\n\n'm'\n6Dh\n\n\n\"School\"\n53h, 63h, 68h, 6Fh, 6Fh, 5Ch\n\n\n\"Joe\"\n4Ah, 6Fh, 65h\n\n\n\"A Bank.\"\n41h, 30h, 42h, 61h, 6Eh, 6Bh, 2Eh\n\n\n\"Joe's\"\n4Ah, 6Fh, 65h, 27h, 73h\n\n\n\n\n\n\n\n\n\nAn instruction consists of an instruction mnemonic followed by zero, one, two, or three operands.\nAn instruction mnemonic is a short word that identifies an instruction, such as mov, add, and sub.\nAn instruction operand can be used for input or output for the instruction. For example, consider the following instruction:\nadd   eax, [x]    ; x is a label for memory location (variable) \n\nadd is the instruction mnemonic\neax is the first operand. This operand acts as an input and output\n[x] is the second operand. This operand acts as an input.\nThe semantic of this instruction is as follows. Add the content of x to eax and store the result into eax (i.e., eax = eax + [x])\nThere is a natural ordering of operands. When instructions have multiple operands, the first one is typically called the destination operand. The second operand is usually called the source operand.\n\nInstruction operand can be:\n\nExplicit, in which the operand appears in the instruction statement (see the example above)\nImplicit, in which the operand does not appear in the statement. For example, consider the following integer multiplication instruction:\n      imul    ebx\nThe operand ebx represents the multiplier. The multiplicand is the register EAX and the product is stored in two registers: EDX and EAX. We are going to explain this instruction in much detail in future lectures.\n\nGenerally, the instructions we are going to study in this course fall under general–purpose Instructions, which perform basic data movement, arithmetic, logic, program flow, and string operations that programmer commonly use to write application and system software. In this course we are going to focus on:\n\nData movement/transfer instructions,\nArithmetic and Logic instructions,\nControl transfer instructions, and\nFlag control instructions"
  },
  {
    "objectID": "lectures/lec02.html#an-assembly-program",
    "href": "lectures/lec02.html#an-assembly-program",
    "title": "Lecture 2: Assembly Language Fundamentals",
    "section": "",
    "text": "Let us consider the following program:\n;\n;   Adding two numbers\n;\n      global _main\n      \n      section .data\nsum   dd      0\n\n      section .code\n_main:\n      mov     eax, 5      ; let eax = 5\n      add     eax, 6      ; add 6 to eax\n      mov     [sum], eax  ; store result into sum\n      \n      ret\n\n\n\nAn assembly program consists of statements. There are three types of statements: instructions, directives, and macros.\nAn instruction is translated by the assembler into one or more bytes of object code (machine code), which will be executed at run time.\nA directive tells the assembler to perform some special tasks, such as allocating memory space for a variable or creating a procedure.\nA macro is “shorthand” for a sequence of other statements.\nBy default, assembly is not case-sensitive.\nAny statement has up to four fields, separated by at least one white space:\n[label:]     instruction   [operand(s)]   [;comment]\n\nThe four fields are displayed in the following diagram:\n\n\n\nThe layout of source lines. Blue rectangle for label; Red rectangle for either instruction or directive; Orange rectangle for operands or arguments; Green rectangle for comment\n\n\n\n\n\n\nA comment always starts with a semicolon character ; and ends with newline character, as shown as red rectangles in the following diagram:\n\nAt the top of every program, you should add a comment block that contains:\n\nThe name of the source code file,\nThe date you created the file,\nThe date you last modified the file,\nThe name of the person who wrote it,\nThe name and version of the assembler used,\nAn overview description of the what the program or library does.\nA copy of the commands used to build the file\nHere is an example:\n; -----------------------------------------------------------------\n; Source name   : addtwo.asm\n; Version       : 1.0\n; Created date  : 10/4/2020\n; Last modified : 22/8/2024\n; Author        : Khalid Elbadawi\n; Compiling     : nasm -fwin32 addtwo.asm (NASM version 2.15)\n; Description   : Store the result of 5 + 6 \n; -----------------------------------------------------------------\n\n\n\n\n\n\nGenerally, programs written in assembly language are divided into sections, which represent memory segments.\nSections are defined by the assembler directive.\nIn NASM, sections are created by using section keyword followed by the section name, such as .data, .bss, or .text\n\nThe .data section: contains data definitions of initialized data items\nThe .bss section: contains data definitions of uninitialized data items\nThe .text section: contains the actual machines instructions (i.e., the code) that make up your program\n\nIn the following diagram, the data section is enclosed by the GREEN rectangle and code (or text) section is enclosed by the RED rectangle:\n\n\n\n\n\n\nA label field is a programmer-chosen identifier. It might identify a variable, a constant, a procedure or an instruction label.\nRules for choosing an identifier are (in NASM):\n\nMust not exceed more than 247 characters\nMust start with a letter, underscore or ?.\nSubsequent characters may also be digits, @, #, $, or dot.\nMust not be a reserved word\n\nIn general, it’s good idea to use descriptive names for identifiers.\nLabels, in NASM, are case sensitive.\n\n\n\n\n\nThere are different types of reserved words:\n\nInstruction mnemonics (the Instruction Set), such as ADD, SUB, MOV.\nRegister names, such as EAX, AX, AL, ch\nDirectives, such as DB, DWORD.\nOperand attributes, such FAR, NEAR, BYTE.\nOperators used in constant expressions.\n\nReserved words are NOT case sensitives\n\n\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\n\n[{+|-}] digits [radix]\n\n\nwhere radix can be\n\nh (hexadecimal),\no or q (octal),\nd (decimal), and\nb (binary)\n\n\n\n\n\n\n\nExample\n\n\n\n\n\n\nInteger constants\nBase\n\n\n\n\n198\ndecimal\n\n\n0200\ndecimal\n\n\n-2d\ndecimal\n\n\n+101b\nbinary\n\n\n1100_0001b\nbinary\n\n\n107o\noctal\n\n\n107q\nstill octal (more readable)\n\n\n23bh\nhexadecimal\n\n\n23Bh\nhexadecimal\n\n\n0ah\nhexadecimal\n\n\n0xC8\nhexadecimal (C syntax)\n\n\n\n\n\n\n\n\n\nCharacters and character string must be enclosed in single quotes, double quotes or back quotes.\n\n\"A\" or \"Hello\"\n'A' or 'Hello'\n`A` or `Hello`\n\nCharacters are stored in contiguous memory and translated into their ASCII codes by the assemblers, so there is no difference between using \"A\" and 41h in an assembly program.\n\n\n\nCharacter/String Literal\nValue in Hex\n\n\n\n\n'm'\n6Dh\n\n\n\"School\"\n53h, 63h, 68h, 6Fh, 6Fh, 5Ch\n\n\n\"Joe\"\n4Ah, 6Fh, 65h\n\n\n\"A Bank.\"\n41h, 30h, 42h, 61h, 6Eh, 6Bh, 2Eh\n\n\n\"Joe's\"\n4Ah, 6Fh, 65h, 27h, 73h\n\n\n\n\n\n\n\n\n\nAn instruction consists of an instruction mnemonic followed by zero, one, two, or three operands.\nAn instruction mnemonic is a short word that identifies an instruction, such as mov, add, and sub.\nAn instruction operand can be used for input or output for the instruction. For example, consider the following instruction:\nadd   eax, [x]    ; x is a label for memory location (variable) \n\nadd is the instruction mnemonic\neax is the first operand. This operand acts as an input and output\n[x] is the second operand. This operand acts as an input.\nThe semantic of this instruction is as follows. Add the content of x to eax and store the result into eax (i.e., eax = eax + [x])\nThere is a natural ordering of operands. When instructions have multiple operands, the first one is typically called the destination operand. The second operand is usually called the source operand.\n\nInstruction operand can be:\n\nExplicit, in which the operand appears in the instruction statement (see the example above)\nImplicit, in which the operand does not appear in the statement. For example, consider the following integer multiplication instruction:\n      imul    ebx\nThe operand ebx represents the multiplier. The multiplicand is the register EAX and the product is stored in two registers: EDX and EAX. We are going to explain this instruction in much detail in future lectures.\n\nGenerally, the instructions we are going to study in this course fall under general–purpose Instructions, which perform basic data movement, arithmetic, logic, program flow, and string operations that programmer commonly use to write application and system software. In this course we are going to focus on:\n\nData movement/transfer instructions,\nArithmetic and Logic instructions,\nControl transfer instructions, and\nFlag control instructions"
  },
  {
    "objectID": "lectures/lec02.html#defining-data",
    "href": "lectures/lec02.html#defining-data",
    "title": "Lecture 2: Assembly Language Fundamentals",
    "section": "Defining Data",
    "text": "Defining Data\n\nIntrinsic Data Types\nIn assembly language, data types are expressed in terms of their sizes (byte, word, doubleword, etc).\n\n\n\nSize\nType\nNote\n\n\n\n\nByte\nBYTE or HWORD\n8 bits\n\n\nWord (two-byte)\nWORD\n16 bits\n\n\nDouble word (2-word)\nDWORD\n32 bits\n\n\nQuad word (4-word)\nQWORD\n64 bits\n\n\nTen-Byte (5-word)\nTBYTE or TWORD\n80 bits\n\n\nDouble-quad word (8-word)\nOWORD or DQWORD\n128 bits\n\n\nQuad-quad word (16-word)\nYWORD\n256 bits\n\n\n32-Word\nZWORD\n512 bits\n\n\n\n\n\nDefining Initialized Data (using Dx)\n\nA data definition with initialization sets aside storage in memory (in data segment) for a variable, with an optional label. The syntax:\n\n\n\n\n\n\nSyntax\n\n\n\n[name:]      directive       initializer [, initializer]\n\n\nname is an identifier to label the allocated memory. The label is always attached to the first memory location.\ndirective is a pseudo-instruction (not real x86 instruction and are used in the instruction field) that can be:\n\nData Definition in the form of Dx\n\n\nDirective\nDescription\n\n\n\n\nDB\nDefine (i.e., Allocate) BYTE\n\n\nDW\nDefine WORD\n\n\nDD\nDefine DWORD\n\n\nDQ\nDefine QWORD\n\n\nDT\nDefine TBYTE\n\n\nDO\nDefine OWORD\n\n\nDY\nDefine YWORD\n\n\nDZ\nDefine ZWORD\n\n\n\nInitializer is used to initialize the allocated memory. Additional initializers, if any, are separated by commas.\nExample\n\n\n\n\n\n\nExamples of Data Definition\n\n\n\nletter:   db    'A'   ; value is 41h\nresp      db    'Y'   ; default user response\nnum1:     db    -91   ; value is A5h\nnum2      dw    -1    ; value is FFFFh\nsum:      dd    0     ; value is 0h\n\n\n\n\nLittle Endian vs. Big Endian\nConsider the following definition\nnum:     dw    1234h\n\nAll x86 microprocessors are byte addressable. This means that each memory address can store only a single byte.\nTherefore, in the above definition, the assembler will allocate two bytes for num. But, the question that may arise: how a CPU can store the initial value into 2-byte memory?\nThere are two ways to store 1234h in memory:\n\nLittle Endian, in which the least significant byte is stored at the smallest memory address\nBig Endian, in which the most significant byte is stored at the smallest memory address.\nThe following diagram illustrates the difference:\n\nx86 microprocessors follow Little Endianness.\n\n\n\n\nMultiple Initializers\n\nThe pseudo-instruction Dx can take multiple initializers.\nIf multiple initializers are used, the memory space is allocated large enough to hold these values.\nRemember, the label is always attached to the first memory location (i.e., first byte).\nExamples: In the comments, the first byte is located at the smallest memory address.\n    db    55h, 56h, 57h   ; 0x55 0x56 0x57\n    db    'a', 55h        ; 0x61 0x55\n    db    'ab', 13, 10, 0 ; 0x61 0x62 0x0D 0x0A 0x00\n    dw    1234h, 5678h    ; 0x34 0x12 0x78 0x56\n    dw    12h, 34h        ; 0x12 0x00 0x34 0x00\n    dw    'ab'            ; 0x61 0x62\n    dw    'abc'           ; 0x61 0x62 0x63 0x00\n    dd    0x12345678      ; 0x78 0x56 0x34 0x12\n   ;db    300             ; invalid \nIn data definitions, the labels are optional and pseudo-instructions are executed by the assembler in sequential. Therefore, the following definition:\nlist    db    10, 20, 30\ncan be written as\nlist    db    10\n        db    20\n        db    30\n\n\n\nDUP Operator\n\nThe syntax of DUP operator:\n\n\n\n\n\n\nSyntax\n\n\n\n[name:]    Dx   &lt;counter&gt; DUP (initializer-list)\n\n\nThe DUP operator duplicates the initializer-list specified number of times\ncounter is an constant 32-bit integer expression.\nDUP operator is useful when allocating space for an array.\nExamples:\n    db  3 dup(0)      ; db  0, 0, 0\n    dw  8 dup(1)      ; dw  1, 1, 1, 1, 1, 1, 1, 1\n    db  4 dup('ABC')  ; db  'ABC', 'ABC', 'ABC', 'ABC' \n\n\n\n\nDefining Uninitialized Data (using RESx)\n\nThe RESx directive is quite similar to the Dx directive, but always specifies the number of elements.\nThe RESx directive defines uninitialized storage space inside the BSS segment.\nThe syntax:\n\n\n\n\n\n\nSyntax\n\n\n\n[name:]      RESx       &lt;counter&gt;\n\n\n\ncounter is the number of x to be reserved. It must be a constant expression.\n\nExamples:\nbuffer:   resb    64    ; reserve 64 bytes\nlist:     resd    100   ; reserve 100 32-bit integers\n\n\n\nDefining Constants\n\nNASM provides a directive, named EQU, to define a symbolic constant.\nThe syntax is\n\n\n\n\n\n\nSyntax\n\n\n\nname    EQU   &lt;expression&gt;\n\n\nExamples:\nESC_KEY   equ   27\nCOUNT     equ   100\nIn the code section:\n          mov   eax, COUNT    ; good style\n          mov   eax, 100      ; bad style\n\n          mov   al, ESC_KEY   ; good style\n          mov   al, 27        ; bad style\n\n\n\nConstant Integer Expression\n\nNASM assembler (and also MASM) supports what is called constant integer expression that must evaluate to a 32-bit integer.\n\n\nAssembler Operators\n\n\n\n\n\n\n\nOperator\nName\nPrecedence\n\n\n\n\n()\nParentheses\n1\n\n\n+, -, ~, !\nUnary plus, negative, negation, logical not\n2\n\n\n*, /, //, %, %%\nmultiplication, unsigned division, signed division, unsigned modulus, signed modulus\n3\n\n\n+, -\nAddition and subtraction\n4\n\n\n&lt;&lt;, &gt;&gt;\nShift to left or right (always unsigned)\n5\n\n\n&\nBitwise AND\n6\n\n\n^\nBitwise XOR\n7\n\n\n|\nBitwise OR\n8\n\n\n\n\nConstant Integer Expression will always be evaluated by the assembler.\n\n\nThe Current Location ($) and Section Location ($$)\n\nOne of the most important symbols of all, shown as $, is called the current location.\nThe assembler handles the current location and section location expressions as follows\n\nWhen the assembler first encounters a section/segment statement, the current location counter ($) and the section location ($$) are set to the beginning of the current section.\nWhen encountering instructions or pseudo-instructions (such as Dx or RESx), the assembler increments the location counter for each byte written to the object file (i.e, after generating the object code). So, you can tell how far into the section you are by using ($ - $$).\n\nIn the following code, the current location expression is used to calculate the string length. The calculation is performed by the assembler.\nmyStr:    db    \"This is a long string, containing \"\n          db    \"any number of characters.\"\nSTRLEN    equ   ($ - myStr)"
  },
  {
    "objectID": "lectures/lec02.html#addressing-modes",
    "href": "lectures/lec02.html#addressing-modes",
    "title": "Lecture 2: Assembly Language Fundamentals",
    "section": "Addressing Modes",
    "text": "Addressing Modes\n\nWe mentioned that a CPU instruction can have zero, one, two, or three operands.\nFor exmaple:\n        add   eax, 5\nThe instruction add takes two operands. The first operand is a CPU register, and the second operand is a constant integer.\nIn assembly language, the way an operand is specified is known as addressing mode.\nGenerally, the addressing modes used by Intel architectures are:\n\nImmediate addressing mode: when an operand is a constant expression\nRegister addressing mode: when an operand is a CPU register\nMemory addressing modes, in which we have\n\nDirect memory addressing mode: when an operand is constant reference to memory location.\nIndirect memory addressing modes: when an operand is reference to memory location and this reference is determined during the running-time.\n\n\n\nThe following table is taken from Intel manuals that describes the standard operand types:\n\nInstruction Operand Notation, 32-bit Mode.\n\n\n\n\n\n\nOperand\nDescription\n\n\n\n\nreg\nAny general-purpose register\n\n\nreg8\n8-bit general-purpose register: AH, AL, BH, BL, CH, CL, DH, DL\n\n\nreg16\n16-bit general-purpose register: AX, BX, CX, DX, SI, DI, SP, BP\n\n\nreg32\n32-bit general-purpose register: EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP\n\n\nsreg\n16-bit segment register: CS, DS, SS, ES, FS, GS\n\n\nimm\n8-, 16-, or 32-bit immediate value\n\n\nimm8\n8-bit immediate byte value\n\n\nimm16\n16-bit immediate word value\n\n\nimm32\n32-bit immediate doubleword value\n\n\nmem\nAn 8-, 16-, or 32-bit memory operand\n\n\nreg/mem8\n8-bit operand, which can be an 8-bit general register or memory byte\n\n\nreg/mem16\n16-bit operand, which can be an 16-bit general register or memory word\n\n\nreg/mem32\n32-bit operand, which can be an 32-bit general register or memory doubleword\n\n\n\n\n\n\nDirect Memory Addressing Mode\n\nA direct memory operand is an operand identifier that refers to a specific offset within the data segment.\nThe offset address must be specified inside square brackets [].\n        section .bss\nsum:    resd      1\n\n        section .text\n_main:\n        mov     eax, 5\n        add     eax, 6\n        mov     [sum], eax\n\n\n\nAddressing mode and Machine Instruction\nExamine the following instruction statements. Assume the variable x is already defined.\n          mov eax, 123h         ; B8 23010000\n    \n          mov   ebx, 123h       ; BB 23010000\n    \n          mov   eax, ebx        ; 8BC3\n    \n          mov   ebx, eax        ; 8BD8\n    \n          mov   WORD [x], 123h  ; C705  00000000  23010000\n    \n          mov   [x], eax        ; A3 00000000\n    \n          mov   ah, 4           ; B4 04\n    \n          mov   al, 13          ; B0 0D   \nIf you read the object file using Hexdump tool, we will get:"
  },
  {
    "objectID": "lectures/lec02.html#data-transfer-instructions",
    "href": "lectures/lec02.html#data-transfer-instructions",
    "title": "Lecture 2: Assembly Language Fundamentals",
    "section": "Data Transfer Instructions",
    "text": "Data Transfer Instructions\n\nData transfer instructions are\n\nMOV, XCHG, MOVSX, MOVZX : to move (as copy) data from source operand to destination operand.\nPUSH, POP, PUSHA, POPA, PUSHAD, POPAD: to move data between an operand and run-time stack.\nCBW, CWD, CDQ, CWDE : to sign-extend an operand\n\nIn this lecture, we will cover MOV, XCHG, MOVSX, and MOVZX . The remaining instructions will be covered in future lectures.\n\n\nMOV Instruction\n\n\n\n\n\n\nSyntax\n\n\n\n        mov   &lt;destination&gt;, &lt;source&gt;\n\n\nThe destination operand’s content changes, but the source operand is unchanged. Right to Left data transfer is similar to the assignment statement in C++ or Java:\n    destination = source;\n\n\n\n\n\n\nRules\n\n\n\n\nBoth operands must be of the same size.\nBoth operands cannot be memory operands.\nThe instruction pointer (IP, EIP, RIP) cannot be a destination operand.\n\n\n\nAccordingly, here is a list of valid MOV instruction formats:\n    mov   reg, reg\n    mov   reg, mem\n    mov   reg, imm\n    mov   mem, reg\n    mov   mem, imm    ; you must specify the size (see next warning)\n\n\n\n\n\n\nNASM, by its design, does not store the type of variables you declared.\nFor example:\nvar     dw    4     ; var is 16-bit variable\nThe following lines are all valid:\n        mov   eax, [var]  ; transfer 4 bytes starting from offset var\n        mov   ax, [var]   ; transfer 2 bytes starting from offset var\n        mov   ah, [var]   ; transfer 1 byte from offset var\n\n\n\n\nExample\n;\n;  adding three numbers\n;\n\n        section .data\narr     dd      4, 28, 35\n\n        section .text\n_main:\n        mov   eax, [arr]      ; move the value 4 to eax\n        add   eax, [arr + 4]  ; add the value 28 to eax\n        add   eax, [arr + 8]  ; add the value 35 to eax\n\n\n\n\n\n\nInvalid MOV statements\n\n\n\n        mov   4, eax      ; dest cannot be imm\n        mov   [x], [y]    ; both operands cannot be memory\n        mov   x, eax      ; dest cannot be imm\n        mov   [x], 10     ; unknown data types (or size)\n\n\n\n\nMemory to Memory\n\n\n\n\n\n\nA single MOV instruction cannot be used to move data directly from one memory location to another.\n; assign x to y (i.e., y = x)\n        mov     eax, [x]\n        mov     [y], eax\n\n\n\n\n\n\n\n\nImmediate to Memory\nIn assembly language, the size of integer literals can be 8, 16, or 32 bits. Therefore, in the following instruction:\n      mov   ax, 5\nthe size of the source operand is unknown. However, the assembler can infer the size of immediate operand by the size of other operand (ax). Thus, the assembler translates the source operand as imm16.\nThe problem arises when the size of the other operand is also unknown; typically when we move data from imm to mem. In this case, you must tell the assembler the amount of bytes to be transferred from the source to destination by specifying the data type of at least one operand (see Intrinsic Data Types).\n\n\n\n\n\n\nExample\n\n\n\n        mov   DWORD [x], 5\n\n\nHere, the size of the first operand is doubleword. The size of the second operand will be inferred from the first one.\n\n\n\nMOVSX Instruction\n\nCan we transfer data from a smaller size to a larger size?\nThe answer is: Yes. But, you must be cautious. Consider the following example; let us assume that we need to transfer data from mem16 to reg32 (ECX).\n      section .data\nv1    dw      -16       ; FFF0h\nv2    dw      16        ; 0010h\n\n      section .text\n\n      mov     ecx, [v1] ; WRONG. ecx=0010 FFF0h\n\n      mov     ecx, 0    ; 0000 0000h\n      mov     cx, [v1]  ; 0000 FFF0h\n\n      mov     ecx, 0FFFFFFFFh\n      mov     cx, [v2]; FFFF 0010h\nMOVSX instruction (move with sign-extension) copies the content of a source operand into a destination operand with sign-extends to 16 or 32 bits.\nThis instruction is only used with signed integers and there are three variants:\n      movsx     reg32, reg/mem8\n      movsx     reg32, reg/mem16\n      movsx     reg16, reg/mem8\nThe following code corrects the above code:\n      movsx     ecx, WORD [v1]  ; ecx = FFFF FFF0h = -16\n\n      movsx     edx, WORD [v2]  ; edx = 0000 0010h = 16\n\n\n\nMOVZX Instruction\n\nMOVZX is similar to MOVSX, but with zero-extend. It is only used with unsigned integers\n\n\n\nXCHG Instruction\n\n\n\n\n\n\nSyntax\n\n\n\n        XCHG    &lt;operand1&gt; , &lt;operand2&gt;\n\n\nThe XCHG (exchange data) instruction exchanges the contents of two operands.\n\n\n\n\n\n\nRules\n\n\n\n\nBoth operands must be of the same size.\nBoth operands cannot be memory operands.\nImmediate operands are not allowed.\nThe instruction pointer (IP, EIP, RIP) cannot be a destination operand.\n\n\n\nAccordingly, this instruction has three formats:\n        XCHG    reg, reg\n        XCHG    reg, mem\n        XCHG    mem, reg\nExample: What is the value of AX and BX after executing the following code:\n        mov     ax, 0A100h\n        mov     bx, 0005h\n        xchg    ah, bl"
  },
  {
    "objectID": "lectures/lec04.html",
    "href": "lectures/lec04.html",
    "title": "Lecture 4: Branching and Looping",
    "section": "",
    "text": "Understand relative and absolute offset addresses\nLearn all instructions provided by the Intel Microprocessors that you need for decision-making logic.\nLearn how to translate IF statement, switch statement, and conditional loop found in high-level languages into assembly language."
  },
  {
    "objectID": "lectures/lec04.html#objectives",
    "href": "lectures/lec04.html#objectives",
    "title": "Lecture 4: Branching and Looping",
    "section": "",
    "text": "Understand relative and absolute offset addresses\nLearn all instructions provided by the Intel Microprocessors that you need for decision-making logic.\nLearn how to translate IF statement, switch statement, and conditional loop found in high-level languages into assembly language."
  },
  {
    "objectID": "lectures/lec04.html#branching",
    "href": "lectures/lec04.html#branching",
    "title": "Lecture 4: Branching and Looping",
    "section": "Branching",
    "text": "Branching\n\nBy default, the CPU loads and executes programs sequentially.\nA branch, or transfer of control, is a way of altering the order in which statements are executed.\nThere are two basic types of transfer:\n\nUnconditional transfer, in which a transfer is occurred unconditionally.\nConditional transfer, in which a transfer is occurred based on a certain condition.\n\n\n\nInstruction Pointer\n\nThe EIP, or instruction pointer , register contains the address of the next instruction to be executed. Certain machine instructions manipulate EIP, causing the program to branch to a new location. These instructions are JMP, Jcc, LOOP, CALL, RET, or IRET.\n\n\nRelative vs Absolute Offset Address\n\nThe EIP can be updated based on a target address.\nThe target address, within the instruction stream, can be relative offset or absolute offset\nA relative offset is a signed displacement to the current value of the EIP.\n\\[ \\text{EIP} = \\text{EIP} + \\text{Target displacement} \\]\nAn absolute address is an offset from the base of the code segment (i.,e., offset from address 0 of a segment).\n\\[ \\text{EIP} = \\text{Target Address} \\]\nRelative address can be specified in either of the following ways\n\n\n\n\n\n\n\nAddress format\nDescription\n\n\n\n\nrel8\nA constant value in the range from -128 to 127 bytes.\n\n\nrel16\nA relative address within the same code segment.\n\n\nrel32\nA relative address within the same code segment.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nA relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed 8-, 16-, or 32-bit immediate value.\n\n\nAbsolute address can be specified as an address in general-purpose register or an address specified using memory addressing mode.\n\n\n\n\nJMP Instruction\n\n\n\n\n\n\nSyntax\n\n\n\n        JMP   &lt;destination&gt;\n\n\n\nThe JMP instruction causes an unconditional transfer to a destination address.\nThe destination (target) operand specifies the address of the instruction being jumped to. This operand can be an immediate value, a general-purpose register, or a memory location.\n\nIn this course, we only consider the immediate value for the destination operand.\n\nThus, the JMP instruction takes the following types (for this course):\n        JMP   rel8          ; relative address\n        JMP   rel16         ; relative address (not supported in 64-bit mode)\n        JMP   rel32         ; relative address\n        JMP   reg/mem16     ; absolute address (not supported in 64-bit mode)\n        JMP   reg/mem32     ; aboslute address (not supported in 64-bit mode)\n\n\nTypes of Jumps:\n\nNear Jump: A jump to instruction within the current code segment (intra-segment jump). Here the displacement is either rel16, rel32, reg/mem16, reg/mem32.\nShort jump: A near jump where the jump is limited to -128 to +127 from the current EIP value. Here the displacement is rel8.\nFar Jump: A jump to an instruction located in a different segment than the current code segment but at the same privilege level (inter-segment jump) (NOT covered).\n\n\n\n\n\n\n\nNote\n\n\n\nThere is no difference in the coding for a relative short jump and for a relative near jump. The assembler uses a short jump if the displacement is within the small range in order to generate more compact code. A near jump is used automatically if the displacement is more than 128 bytes away.\n\n\n\n\nExample\n        mov   ax, 0\n  top:\n        mov   bx, 5\n        add   bx, 1\n        .\n        .\n        .\n        jmp   top\n        \n\n\n\nLOOP Instruction\n\n\n\n\n\n\nSyntax\n\n\n\n        LOOP    &lt;destination&gt;\n\n\n\n\n\n\n\n\nRule\n\n\n\n\nThe destination operand must be rel8.\n\n\n\n\nThe loop instruction repeats a block of statements a specific number of times (determined by ECX register).\nECX is automatically used as a counter and is decremented each time the loop repeats.\nExample\n\n\n\n        mov   ax, 1\n        mov   ecx, 5\n  top:\n        add   ax, ax\n        loop  top\n\n\n\n\n\n\nMore Examples\n\nExample 1 Write an assembly program to compute the sum of the following series\n\\[\nS = 1 + 2 + 4 + 8 + \\cdots + 1024\n\\]\n\nSolution:\nHere, we can re-write the series as follows:\n\\[\nS = 2^0 + 2^1 + 2^2 + 2^3 + \\cdots + 2^{10}\n\\]\nTherefore, we can set ECX to 10. However, setting ECX to 10 implies that the loop starts from 10 and ends at 1. This also implies that \\(2^0\\) won’t be added. To handle it, we can add \\(2^0\\) when we initialize the sum \\(S\\).\n        section .data\nvarS:   dd      0\n\n        section .text\n_main:\n        mov     eax, 1        ; first elm is 1\n        add     [varS], eax   ; add 1 to S\n        mov     ecx, 10       ; set loop counter to 10\ntop:\n        add     eax, eax      ; set eax = 2 * eax\n        add     [varS], eax   ; add eax to S\n        loop    top\n        \n        ret\n\n\n\n\n\n\nIn the previous program, we are accessing a memory location in each iteration. Therefore, if the number of iterations is quite high, then we have too many memory accesses.\nMost CPUs have a cache memory, which is a smaller, faster memory and located closer to the processor core.\nWhen accessing the memory location varS for the first time, the content is stored into the main memory (RAM) (cache miss) and into the cache memory. However, in the subsequent memory accesses, the CPU is accessing the cache memory rather than the main memory (we call it temporal locality).\nTo avoid too many memory accesses, we can store the sum in a CPU register and then we update varS after the loop has been completely executed. This will definitely improve the program performance (in terms of time)\n\n\n\nAnother solution:\n        section .bss\nvarS:   resd    1\n\n        section .text\n_main:\n        ; we store the sum in EBX register\n        mov     eax, 1        ; first elm is 1\n        mov     ebx, eax      ; set sum (ebx) to 1\n        mov     ecx, 10       ; set loop counter to 10\ntop:\n        add     eax, eax      ; set eax = 2 * eax\n        add     ebx, eax      ; add eax to sum (ebx)\n        loop    top\n        \n        mov     [varS], ebx   ; store the result \n        \n        ret\n\nExample 2 Suppose you have the following signed 16-bit integer array hardcoded in your program:\n  arrX[] = {13, 22, 18, 10, 25}\nWrite an assembly program to store the above array in the data section and then calculate the sum of its elements. Store the sum in sum variable.\n\nSolution:\n        section .data\narrX:   dw      13, 22, 18, 10, 25\nARRSIZ  equ     ($ - arrX) / 2\nsum:    dw      0\n\n        section .text\n_main:\n        mov     edi, arrX     ; edi points to 1st elm\n        mov     ecx, ARRSIZ   ; set counter\n        mov     ax, 0         ; set sum to 0\nL1:\n        add     ax, [edi]     ; load next elm and add it to sum\n        add     edi, 2        ; set edi to point to next elm\n        loop    L1            ; loop\n        \n        mov     [sum], ax       ; store sum\n        ret\n\n\nNested Loop\n\nHow to implement the following nested loop:\nfor (int i=100; i != 0; i--)\n  for (int j=50; j != 0; j--)\n    ...\nin assembly language?\nUnfortunately, the LOOP instruction has only one counter, which is ECX.\nTo tackle this problem, we must preserve the outer loop counter before executing the inner loop, and restore the outer loop counter before executing the outer’s LOOP instruction. Here is an a solution:\n        section .bss\ncount:  resd    1         ; to store outer loop counter\n\n        section .text\n\n        .\n        .\n        mov     ecx, 100  ; # of iterations for outer loop\nOUTER:\n        mov     [count], ecx  ; preserve outer loop counter\n        mov     ecx, 50   ; # of iterations for inner loop\nINNER:\n        .\n        .\n        loop    INNER\n        mov     ecx, [count]\n        loop    OUTER\nIn future lecture, we can enhance this solution by using run-time stack.\n\n\n\n\nTEST Instruction\n\n\n\n\n\n\nSyntax\n\n\n\n        TEST    &lt;destination&gt;, &lt;source&gt;\n\n\n\nTEST instruction performs an implied AND operation of two operands and set the SF, ZF, and PF flags according to the results.\nThe flags can then be tested by the conditional jump or loop instruction.\nTEST instruction differs from the AND instruction in that it does not alter either of the operands\n\n\n\n\n\n\n\nRules\n\n\n\n\nBoth operands must be of the same size\nBoth operands cannot be memory locations\nDestination operand cannot be immediate\n\n\n\n\n\nCMP Instruction\n\n\n\n\n\n\nSyntax\n\n\n\n        CMP     &lt;destination&gt;, &lt;source&gt;\n\n\n\nCMP instruction is used to compare between two integral values (integers or characters).\nIt performs an implied subtraction of a source operand from a destination operand.\nIt affects ALL status flags according to the value the destination would have had if actual subtraction had taken place. Through these flags, we can compare the two operands:\n\nIf the two operands are treated as unsigned, then\n\n\n\nZF\nCF\nComparison Result\n\n\n\n\n0\n0\ndestination &gt; source\n\n\n0\n1\ndestination &lt; source\n\n\n1\n*\ndestination = source\n\n\n\nIf the two operands are treated as signed, then\n\n\n\nZF\nSF\nOF\nComparison Result\n\n\n\n\n0\n0\n0\ndestination &gt; source\n\n\n0\n0\n1\ndestination &lt; source\n\n\n0\n1\n0\ndestination &lt; source\n\n\n0\n1\n1\ndestination &gt; source\n\n\n1\n*\n*\ndestination = source\n\n\n\n\nCMP is a valuable tool for creating conditional logic structures. When you follow CMP with a conditional jump instruction, the result is the assembly language equivalent of a flow control statement (such as if, if else, switch case, while, do while).\nExample:\n      mov   ax, 100\n      mov   cx, 100\n      cmp   ax, cx    ; ZF = 1\n\n      jz    skip      ; JUMP to label \"skip\" only if ZF is set\n\n      add   ax, 1\nskip:\n      add   cx, 2\nThe flow control of the previous code is shown below:\n\n\n\n\nJcc Instruction (Conditional Jump)\n\n\n\n\n\n\nSyntax\n\n\n\n        Jcc   &lt;destination&gt;\n\n\n\nThe Jcc instruction causes a conditional transfer to a destination address, which can be specified relatively or absolutely.\nThe Jcc instruction supports near jump only.\nA conditional jump instruction branches to a destination label when a condition is true. Otherwise, if the condition is false, the instruction immediately following the conditional jump is executed.\n\n\n\n\n\nBackward Reference\n\n\n\n\n\n\n\nForward Reference\n\n\n\n\n\n\nTypes of Conditional Jump\n\nThe x86 instruction set has a large number of conditional jump instructions. They are able to compare signed and unsigned integers and perform actions based on the values of individual CPU flags.\nThe conditional jump instructions can be divided into four groups:\n\nJumps based on specific flag values\nJumps based on equality between operands or the value of RCX, ECX, or CX\nJumps based on comparisons of unsigned operands\nJumps based on comparisons of signed operands\n\n\n\n\nJump Based on Specific Flag Values\n\n\n\nMnemonic\nDescription\nFlags/Registers\n\n\n\n\nJZ\nJump if zero\nZF = 1\n\n\nJNZ\nJump if not zero\nZF = 0\n\n\nJC\nJump if carry\nCF = 1\n\n\nJNC\nJump if not carry\nCF = 0\n\n\nJO\nJump if overflow\nOF = 1\n\n\nJNO\nJump if not overflow\nOF = 0\n\n\nJS\nJump if signed\nSF = 1\n\n\nJNS\nJump if not signed\nSF = 0\n\n\nJP or JPE\nJump if parity (even)\nPF = 1\n\n\nJNP or JPO\nJump if not parity (odd)\nPF = 0\n\n\n\n\n\nJump Based on Equality or The Value of CX/ECX/RCX\n\n\n\nMnemonic\nDescription\n\n\n\n\nJE\nJump if equal\n\n\nJNE\nJump if not equal\n\n\nJCXZ\nJump if CX = 0\n\n\nJECXZ\nJump if ECX = 0\n\n\nJRCXZ\nJump if RCX = 0 (64-bit mode)\n\n\n\n\n\nJump Based on Comparisons of Unsigned Operands\n\n\n\n\n\n\n\n\nMnemonic\nDescription\nFlags\n\n\n\n\nJA\nJump if above\nCF = 0 and ZF = 0\n\n\nJNBE\nJump if not below of equal (same as JA)\nCF = 0 and ZF = 0\n\n\nJAE\nJump if above or equal\nCF = 0\n\n\nJNB\nJump if not below (same as JAE)\nCF = 0\n\n\nJB\nJump if below\nCF = 1 and ZF = 0\n\n\nJNAE\nJump if not above or equal (same as JB)\nCF = 1 and ZF = 0\n\n\nJBE\nJump if below of equal\nCF = 1 or ZF = 1\n\n\nJNA\nJump if not above (same as JBE)\nCF = 1 or ZF = 1\n\n\n\n\n\nJump Based on Comparisons of Signed Operands\n\n\n\n\n\n\n\n\nMnemonic\nDescription\nFlags\n\n\n\n\nJG\nJump if greater\nZF=0, SF=OF\n\n\nJNLE\nJump if not less or equal (same as JG)\nZF=0, SF=OF\n\n\nJGE\nJump if greater or equal\nSF=OF\n\n\nJNL\nJump if not less (same as JGE)\nSF=OF\n\n\nJL\nJump if less\nSF != OF\n\n\nJNGE\nJump if not greater or equal (same as JL)\nSF != OF\n\n\nJLE\nJump if less or equal\nZF=1 or SF != OF\n\n\nJNG\nJump if not greater (same as JLE)\nZF=1 or SF != OF\n\n\n\n\n\nAffected Flags\n\nNo conditional jump instruction changes any flag value.\n\n\n\nExamples\n\nExample 3  \n      mov   edx, -1\n      cmp   edx, 0\n      jnl   L5      ; jump if EDX .nl. 0 (false) =&gt; no jump\n      jnle  L5      ; jump if EDX .nle. 0 (false) =&gt; no jump\n      jl    L1      ; jump if EDX &lt; 0 (true) =&gt; jump to L1\n\n\nExample 4  \n      mov   bx, 35\n      cmp   bx, 32\n      jb    L4      ; jump if BX &lt; 32 (false) =&gt; no jump\n      jbe   L4      ; jump if BX &lt;= 32 (false) =&gt; no jump\n      jae   L3      ; jump if BX &gt;= 32 (true) =&gt; jump to L3\n\n\nExample 5  \n      ; repeat 10 times\n      mov   ecx, 0\ntop:\n      \n      ; loop statement\n      \n      inc   ecx\n      cmp   ecx, 10\n      jb    top       ; jump if ECX &lt; 10"
  },
  {
    "objectID": "lectures/lec04.html#implementing-high-level-flow-structures",
    "href": "lectures/lec04.html#implementing-high-level-flow-structures",
    "title": "Lecture 4: Branching and Looping",
    "section": "Implementing High-Level Flow Structures",
    "text": "Implementing High-Level Flow Structures\nIn this section, you will learn how to translate:\n\nif statement\nif-else statement\nswitch statement\nfor loop\nwhile loop\ndo while loop\n\ninto assembly language.\n\nImplementing IF statements\n\nExample 6 Translate the following if statement into assembly language. Assume the variable x is unsigned int.\nif (x &gt; 2000)\n  x = x/2;\n\nSolution:\n    mov   eax, [x]\n    cmp   eax, 2000\n    jbe   ENDIF\n    mov   edx, 0\n    mov   ebx, 2\n    div   ebx\n    mov   [x], eax\nENDIF:\n      \n\nExample 7 Let us translate the following if statement, assuming the variables are declared as int:\nif (value &lt; 10)\n  smallCount++;\nelse\n  largeCount++;\n\nSolution:\n    mov   eax, [value]\n    cmp   eax, 10\n    jnl   ELSE\n    \n    inc   DWORD [smallCount]\n    jmp   ENDIF\nELSE:\n    inc   DWORD [largeCount]\nENDIF:\n\nExample 8 Translate the following statement (all variables are declared as int):\nif ( (total &gt;= 100) and (count = 10) )\n  total += value;\n\nSolution:\n    mov   eax, [total]\n    cmp   eax, 100\n    jl    ENDIF\n    cmp   DWORD [count], 10\n    jnq   ENDIF\n    \n    add   eax, [value]\n    mov   [total], eax\nENDIF:\n    \n\nExample 9 Translate the following statement (all variables are declared as int):\nif ( (total &gt;= 100) or (count = 10) )\n  total += value;\n\nSolution:\n    mov   eax, [total]\n    cmp   eax, 100\n    jge   THEN\n    cmp   DWORD [count], 10\n    jnq   ENDIF\nTHEN:\n    add   eax, [value]\n    mov   [total, eax]\nENDIF:\n    \n\nExample 10 Find the smallest of three integers:\nif (a &lt;= b and a &lt;= c)\n  smallest = a;\nelse if (b &lt;= c)\n  smallest = b;\nelse\n  smallest = c;\n\nSolution:\n    mov   eax, [a]\n    mov   ebx, [b]\n    mov   ecx, [c]\n    cmp   eax, ebx\n    jg    ELSE1\n    cmp   eax, ecx\n    jg    ELSE1\n    \n    mov   [smallest], eax\n    jmp   ENDIF\n    \nELSE1:\n    cmp   ebx, ecx\n    jg    ELSE2\n    \n    mov   [smallest], ebx\n    jmp   ENDIF\n\nELSE2:\n    mov   [smallest], ecx\n    \nENDIF:\n\nExample 11 Translate the following switch statement:\nswitch (x) {\ncase 0:\n  y = 1;\n  break;\ncase 2:\n  y = 10;\n  break;\ncase 4:\n  y = 100;\n  break;\ndefault:\n  y = 0;\n}\n\nSolution:\n      mov   eax, [x]\n      cmp   eax, 0\n      jnq   CASE2\n      \n      mov   ebx, 1\n      jmp   ENDCASE\nCASE2:\n      cmp   eax, 2\n      jnq   CASE3\n      \n      mov   ebx, 10\n      jmp   ENDCASE\nCASE3:\n      cmp   eax, 4\n      jnq   CASE4\n      \n      mov   ebx, 100\n      jmp   ENDCASE\nCASE4:\n      mov   ebx, 0\nENDCASE:\n      mov   [y], ebx\n\nExample 12 Translate the following for loop:\nsum = 0;\nfor (int i=1; i&lt;100; i+=2)\n  sum += i;\n\nSolution:\n    mov   eax, 0\n    mov   ecx, 1\ntop:\n    add   eax, ecx\n    add   ecx, 2\n    cmp   ecx, 100\n    jl    top\n    mov   [sum], eax\n\nExample 13 Translate the following while loop:\nd1 = 100;\nd2 = 0;\nt = 0;\nwhile (d2 &lt;= d1) {\n  t = t + 1;\n  d1 = d1 - 3;\n  d2 = 2*t - 1;\n}\n\nSolution:\n    mov   eax, 100\n    mov   ebx, 0\n    mov   ecx, 0;\nWHILE:\n    cmp   ebx, eax\n    jg    ENDWHILE\n    \n    inc   ecx\n    sub   eax, 3\n    imul  ebx, ecx, 2\n    sub   ebx, 1\n    jmp   WHILE\nENDWHILE\n    mov   [d1], eax\n    mov   [d2], ebx\n    mov   [t], ecx\n\nExample 14 Translate the following do while loop:\ncount = 1;\nsum = 0;\ndo {\n  sum = sum / 2 + count * 2\n  count++;\n} while (sum &lt; 1000 or count &lt;= 100);\n\nSolution:\n    mov   ecx, 1;\n    mov   eax, 0\nDOWHILE:\n    cdq\n    mov   ebx, 2\n    idiv  ebx\n    add   eax, ecx\n    add   eax, ecx\n    inc   ecx\n    \n    cmp   eax, 1000\n    jl    DOWHILE\n    cmp   ecx, 100\n    jle   DOWHILE\n    \n    mov   [count], ecx\n    mov   [sum], eax"
  }
]