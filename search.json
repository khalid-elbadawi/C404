[
  {
    "objectID": "lectures/lec01.html",
    "href": "lectures/lec01.html",
    "title": "Lecture 1: Basic Concepts",
    "section": "",
    "text": "Revise the following representations:\n\nBinary integers\n\nUnsigned binary integers:\n\nTranslating unsigned binary integer to decimal\nTranslating unsigned decimal to binary\n\nSigned binary integers:\n\n1’s complement representation\n2’s complement representation\n\n\nHexadecimal integers\n\nHexadecimal 2’s complement\nTranslating binary integer to hexadecimal and vice versa.\nTranslating hexadecimal integer to decimal and vice versa.\nConverting a hexadecimal integer t\n\n\n\n\n\n\n\n\n\nExample\n\n\n\n\nConvert the following number \\((1100101)_2\\) to decimal. \\[\\begin{align*}\n     1100101_2 &= 1\\times2^0 + 0\\times2^1 + 1\\times2^2 + 0\\times2^3 + 0\\times2^4 + 1\\times2^5 + 1\\times2^6 \\\\\n     &= 1+4+32+64=101_{10}\n\\end{align*}\\]\nConvert the following number \\((A13)_{16}\\) to decimal.\n\\[\\begin{align*}\n     A13_{16} &= 3\\times16^0 + 1\\times16^1 + 10\\times16^2 \\\\\n     &= 3 + 16 + 2560 = 2579_{10}\n\\end{align*}\\]\nConvert the following number \\(-14_{10}\\) to one-word binary.\n\\[\\begin{align*}\n     14_{10} = 8 + 4 + 2 = 1110_2 &= 0000\\; 0000\\; 0000\\; 1110_2 \\\\\n     Neg &= 1111\\; 1111\\; 1111\\; 0001_2 \\\\\n     +1 &= 1111\\; 1111\\; 1111\\; 0010_2\n\\end{align*}\\]\n\\(\\therefore -14_{10} = 1111\\;1111\\;1111\\;0010_2\\)\nConvert the following number \\(-14_{10}\\) to one-word hexadecimal\n\\(-14_{10}\\) = FFF216\n\n\n\n\nBinary-Coded Decimal (BCD) Numbers:\n\nEvery decimal digit is represented by 4 binary bits, from 0000 to 1001.\nTwo representations: Unpacked BCD and packed BCD.\nIn unpacked BCD, one decimal digit is encoded in each binary byte. While, in packed BCD, two decimal digits are encoded in each binary byte.\n\n\n\n\nDecimal Number\nUnpacked (in Hex)\nPacked (in Hex)\n\n\n\n\n\\((176)_{10}\\)\n01 07 06\n01 76\n\n\n\nInteger storage sizes\n\n\n\nStorage Name\nSize in BYTE\nsize in BITS\n\n\n\n\nbyte\n1\n8\n\n\nword\n2\n16\n\n\ndoubleword\n4\n32\n\n\nquadword\n8\n64\n\n\n\n\n\n\n\n\nCharacters are represented by using character set, which is one-to-one mapping of characters to integers.\n\n\n\nCharacter set\nCharacter size\n\n\n\n\nASCII\n7 bits\n\n\nANSI\n8 bits\n\n\nUTF-8\n8 bits\n\n\nUTF-16\n16 bits\n\n\nUTF-32\n32 bits\n\n\n\nUTF stadnds for Unicode Transformation Format.\nASCII Strings\n\nStrings are stored in memory as a succession of bytes containing ASCII codes. For example, \"ABC123\" is stored in memory as 41h, 42h, 43h, 31h, 32h, and 33h.\nA null-terminated string is a string of characters followed by a single byte containing zero (NULL). For example, the null-terminated string \"ABC123\" is stored in memory as 41h, 42h, 43h, 31h, 32h, 33h, and 00h.\n\n\n\n\n\n\nReal numbers are represented using the binary representation of IEEE 754 Standard.\nThe representation in memory:\n\n\n\nMemory layout for floating point\n\n\nwhere s is the sign bit, e is the exponent, and f is the significand.\n\\(x = (-1)^s (1 + f) \\times 2^m\\), where \\(m = e - bias\\)\nFloating-point Types:\n\n\n\nType\nSize\nExponent\nFraction\nBias\n\n\n\n\nSingle-precision\n32\n8\n23\n127\n\n\nDouble-precision\n64\n11\n52\n1023\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n\nConvert \\(-11.375_{10}\\) to single-precision binary representation?\n\\(11_{10} = (1011)_2\\)\n\\(0.375_{10} = (2^{-2} + 2^{-3}) = 0.25 + 0.125 = (.011)_2\\)\n\n\\(\\therefore 11.375_{10} = (1011.011)_2 = 1.011011 \\times 2^{+3}\\)\nTherefore,\ns = 1 (sign is enabled)\ne = 3 + 127 = 130 = (1000 0010)2\nf = (011011)2\nThe representation is: \\(1100\\,\\,0001 \\,\\, 0011 \\,\\, 0110 \\,\\, 0000 \\,\\, 0000 \\,\\, 0000 \\,\\, 0000_2\\) = C136000016\n\n\n\n\n\n\nConversion\n\n\n\n\n\n\nFloating-point representation is NOT recommended to store money amount. In languages such as Java or C++, floating point values have certain rounding characteristics that make it difficult to compare them for equality. The common example to illustrate the problem is 0.1 + 0.2 != 0.3.\nSome applications use BCD (such as BigInteger class in the Java class library).",
    "crumbs": [
      "Lectures",
      "Lecture 1: Basic Concepts"
    ]
  },
  {
    "objectID": "lectures/lec01.html#data-representation",
    "href": "lectures/lec01.html#data-representation",
    "title": "Lecture 1: Basic Concepts",
    "section": "",
    "text": "Revise the following representations:\n\nBinary integers\n\nUnsigned binary integers:\n\nTranslating unsigned binary integer to decimal\nTranslating unsigned decimal to binary\n\nSigned binary integers:\n\n1’s complement representation\n2’s complement representation\n\n\nHexadecimal integers\n\nHexadecimal 2’s complement\nTranslating binary integer to hexadecimal and vice versa.\nTranslating hexadecimal integer to decimal and vice versa.\nConverting a hexadecimal integer t\n\n\n\n\n\n\n\n\n\nExample\n\n\n\n\nConvert the following number \\((1100101)_2\\) to decimal. \\[\\begin{align*}\n     1100101_2 &= 1\\times2^0 + 0\\times2^1 + 1\\times2^2 + 0\\times2^3 + 0\\times2^4 + 1\\times2^5 + 1\\times2^6 \\\\\n     &= 1+4+32+64=101_{10}\n\\end{align*}\\]\nConvert the following number \\((A13)_{16}\\) to decimal.\n\\[\\begin{align*}\n     A13_{16} &= 3\\times16^0 + 1\\times16^1 + 10\\times16^2 \\\\\n     &= 3 + 16 + 2560 = 2579_{10}\n\\end{align*}\\]\nConvert the following number \\(-14_{10}\\) to one-word binary.\n\\[\\begin{align*}\n     14_{10} = 8 + 4 + 2 = 1110_2 &= 0000\\; 0000\\; 0000\\; 1110_2 \\\\\n     Neg &= 1111\\; 1111\\; 1111\\; 0001_2 \\\\\n     +1 &= 1111\\; 1111\\; 1111\\; 0010_2\n\\end{align*}\\]\n\\(\\therefore -14_{10} = 1111\\;1111\\;1111\\;0010_2\\)\nConvert the following number \\(-14_{10}\\) to one-word hexadecimal\n\\(-14_{10}\\) = FFF216\n\n\n\n\nBinary-Coded Decimal (BCD) Numbers:\n\nEvery decimal digit is represented by 4 binary bits, from 0000 to 1001.\nTwo representations: Unpacked BCD and packed BCD.\nIn unpacked BCD, one decimal digit is encoded in each binary byte. While, in packed BCD, two decimal digits are encoded in each binary byte.\n\n\n\n\nDecimal Number\nUnpacked (in Hex)\nPacked (in Hex)\n\n\n\n\n\\((176)_{10}\\)\n01 07 06\n01 76\n\n\n\nInteger storage sizes\n\n\n\nStorage Name\nSize in BYTE\nsize in BITS\n\n\n\n\nbyte\n1\n8\n\n\nword\n2\n16\n\n\ndoubleword\n4\n32\n\n\nquadword\n8\n64\n\n\n\n\n\n\n\n\nCharacters are represented by using character set, which is one-to-one mapping of characters to integers.\n\n\n\nCharacter set\nCharacter size\n\n\n\n\nASCII\n7 bits\n\n\nANSI\n8 bits\n\n\nUTF-8\n8 bits\n\n\nUTF-16\n16 bits\n\n\nUTF-32\n32 bits\n\n\n\nUTF stadnds for Unicode Transformation Format.\nASCII Strings\n\nStrings are stored in memory as a succession of bytes containing ASCII codes. For example, \"ABC123\" is stored in memory as 41h, 42h, 43h, 31h, 32h, and 33h.\nA null-terminated string is a string of characters followed by a single byte containing zero (NULL). For example, the null-terminated string \"ABC123\" is stored in memory as 41h, 42h, 43h, 31h, 32h, 33h, and 00h.\n\n\n\n\n\n\nReal numbers are represented using the binary representation of IEEE 754 Standard.\nThe representation in memory:\n\n\n\nMemory layout for floating point\n\n\nwhere s is the sign bit, e is the exponent, and f is the significand.\n\\(x = (-1)^s (1 + f) \\times 2^m\\), where \\(m = e - bias\\)\nFloating-point Types:\n\n\n\nType\nSize\nExponent\nFraction\nBias\n\n\n\n\nSingle-precision\n32\n8\n23\n127\n\n\nDouble-precision\n64\n11\n52\n1023\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n\nConvert \\(-11.375_{10}\\) to single-precision binary representation?\n\\(11_{10} = (1011)_2\\)\n\\(0.375_{10} = (2^{-2} + 2^{-3}) = 0.25 + 0.125 = (.011)_2\\)\n\n\\(\\therefore 11.375_{10} = (1011.011)_2 = 1.011011 \\times 2^{+3}\\)\nTherefore,\ns = 1 (sign is enabled)\ne = 3 + 127 = 130 = (1000 0010)2\nf = (011011)2\nThe representation is: \\(1100\\,\\,0001 \\,\\, 0011 \\,\\, 0110 \\,\\, 0000 \\,\\, 0000 \\,\\, 0000 \\,\\, 0000_2\\) = C136000016\n\n\n\n\n\n\nConversion\n\n\n\n\n\n\nFloating-point representation is NOT recommended to store money amount. In languages such as Java or C++, floating point values have certain rounding characteristics that make it difficult to compare them for equality. The common example to illustrate the problem is 0.1 + 0.2 != 0.3.\nSome applications use BCD (such as BigInteger class in the Java class library).",
    "crumbs": [
      "Lectures",
      "Lecture 1: Basic Concepts"
    ]
  },
  {
    "objectID": "lectures/lec01.html#intel-microprocessors",
    "href": "lectures/lec01.html#intel-microprocessors",
    "title": "Lecture 1: Basic Concepts",
    "section": "Intel Microprocessors",
    "text": "Intel Microprocessors\n\nConventionally, Intel microprocessors are known as x86 processors.\nx86 microprocessors are divided into three families: x86-16, x86-32 and x86-64.\nAll Intel microprocessors are byte addressable.\nIn 1974, Intel has announce 8080 CPU: 8-bit CPU (2Mhz) and 16-bit address bus (64KB).\nIn 1978, 8086 CPU has been introduced with 16-bit CPU (16-bit registers and 16-bit external data bus) and 20-bit address bus with CPU speed ranging from 5MHz to 10MHz.\n\nMemory addresses start from 000000H to 0FFFFFH (1MB)\nThe address space is divided into segments. A segment is a region of memory that begins on a paragraph boundary and extends for some number of bytes (&lt;= 64K).\nA paragraph is a measure of memory equal to 16 bytes.\n8086 CPUs have six 16-bit segment registers: CS, DS, SS,ES, GS, and FS. -The physical address is constructed by two registers: segment address : offset address.\n\nIn 1982, Intel 286 introduced protected mode operation with four privilege levels. The address bus was 24-bit providing 16MB physical memory.\nThe Intel 386 (1985) was the first 32-bit CPU (80386 CPUs) with 32-bit address bus (addressable up to 4G).\n\n80386 CPUs are backward compatible with 8086 CPUs and hence the term x86 family.\nIn addition, it supports for :\n\nA segmented–memory model and a flat memory model.\nPaging, with a fixed 4KB page size providing a method for virtual memory management.\nSupport for 3-stage instruction pipeline (Fetch-Decode-Execute) .\n\n\nIntel 486 (1989) processors are all based on IA-32 architecture with additional support for parallel execution capabilities (ILP):\n\nIt supports 5-stage instruction pipeline.\nIt supports 8KB on-chip L1-cache (using Write-through policy)\nIt has an integrated x87 FPU\n\nIntel Pentium Processor (1993), also known unofficially as P5 or Intel 586, marked a significant advancement in microarchitecture technology. It supports:\n\nSuperscalar architecture, which allows to execute more than one instruction per clock cycle\n8KB L1 cache devoted for code and another 8KB L1 cache devoted for data.\nIntroduced MMX technology, which uses the single-instruction, multiple data (SIMD) execution model with 64-bit registers.\n\nIntel P6 Family (1995-1999), which includes Intel Pentium Pro, Intel Pentium II and III, and Intel Celeron, was introduced.\nIntel 64 architecture was introduced in the Intel Pentium 4 Processor (Extreme Edition) in 2005.\nThe 2010 Intel processor family (First Generation) spans Intel Core i7, i5 and i3 processors. In 2017, Intel Core i9 was introduced. The current generation is 14. Intel currently has several sub-families:\n\nIntel Xeon Processors for data centers and workstations.\nIntel Core Ultra Processors for AI and immersive graphics.\nIntel Core Processors for laptops and desktops.\nIntel Atom Processors for mobile and IoT devices",
    "crumbs": [
      "Lectures",
      "Lecture 1: Basic Concepts"
    ]
  },
  {
    "objectID": "lectures/lec01.html#ia-32-basic-execution-environment",
    "href": "lectures/lec01.html#ia-32-basic-execution-environment",
    "title": "Lecture 1: Basic Concepts",
    "section": "IA-32 Basic Execution Environment",
    "text": "IA-32 Basic Execution Environment\nAs an assembly programmer, you should know the execution environment either for IA-32 or Intel 64 processor.\nAny program running on an IA-32 processor is given a set of resources for executing instructions and for storing code, data and state information.\nThe basic execution environment includes memory (the address space), general purpose data registers, segment registers, the flag register, and the instruction pointer register.\n\nModes of Operation in IA-32\nModes of operation define the memory layout and how a program can address memory (using registers). It also determines which instructions are accessible.\nIA-32 processors have three primary modes of operation:\n\nProtected mode, in which programs are given separate memory areas named segments, and the processor prevents programs from referencing memory outside their assigned segments. This is the default mode.\nReal–Adress mode, in which programs can access to system memory and hardware devices. OS prevents programmers to swtich to this mode.\nSystem Management mode, in which it provides an OS with a mechanism for implementing functions such as power management and system security. These functions are usually implemented by computer manufacturers.\n\nA sub–mode, named virtual-8086, is a special case of protected mode, in which MS–DOS programs (real-mode software) can be executed in a safe environment.\n\nModes of Operations in Intel 64\nThe Intel 64 architecture adds IA-32e mode, which has two sub-modes:\n\ncompatibility mode, which permits legacy 16-bit and 32-bit applications to run without re-compilation under a 64-bit Operating System. Compatibility mode is similar to 32-bit protected mode.\n64-bit mode, which enables a program to access 64-bit linear address space.\n\n\n\n\nCPU Registers\n\nSegment Registers\n\nThe 8086, 8088 and and 80286 have exactly four segment registers specifically designated as holders of segment address.\nThe 80386 and later CPUs have two more that can be used in real mode.\nThe segment registers:\n\nCS, which stands for code segment\nDS, which stadnds for data segment\nSS, which stands for stack segment\nES, which stands for extra segment.\nFS and GS. They are both additional “extra” segments.\n\nAll segment registers are 16 bits in size, irrespective of the CPU architecture.\nSegment registers was to allow 20 bits of address space to be addressed by two 16-bit registers (in the form of segment address : offset address).\nIn IA-32 architecture, segment registers are used only by the operating system.\nThe segment registers are not used in x64 architecture.\n\n\n\nGeneral-Purpose Registers (GPRs)\n\nThe 32-bit GPRs are EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP.\nGPRs are primarily used for\n\narithmetic and logical operations.\naddress calculations.\nmemory pointers\n\nAlthough all of these registers are available for general storage of operands, ESP register holds the stack pointer and as general rule should not be used for another purpose.\n\n\n\nSome general-purpose registers have specialized uses:\n\nEAX is used for multiplication and division instructions.\nECX is automatically used as loop counter.\nESP addresses data on the stack.\nESI and EDI are used by high–speed memory transfer instructions.\nEBP is used by high–level languages to reference function parameters and local variables on the stack. It should not be used for ordinary arithmetic or data transfer.\n\n\n\n\nThe Flag Register (EFLAGS register)\n\n\nEFLAGS consists of individual binary bits that control the CPU operation or reflect the status of last executed instruction\nSome instructions test and manipulate individual flags\nA flag is set when it equals 1; it is clear when it equals 0.\nSome of the flags in the EFLAGS register can be modified directly, using special-purpose instructions.\nThe status flags (bits 0, 2, 4, 6, 7, and 11) of the EFLAGS register indicate the results of arithmetic instructions, such as the ADD, SUB, MUL, and DIV instructions. The functions of the status flags are as follows:\n\n\n\n\n\n\n\nFlag\nDescription\n\n\n\n\nCF (bit 0)\nCarry flag. Set if an arithmetic operation generates a carry or a borrow out of the most-significant bit of the result; cleared otherwise. This flag indicates an overflow condition for unsigned-integer arithmetic. It is also used in multiple-precision arithmetic.\n\n\nPF (bit 2)\nParity flag. Set if the least-significant byte of the result contains an even number of 1 bits; cleared otherwise.\n\n\nAF (bit 4)\nAdjust flag. Set if an arithmetic operation generates a carry or a borrow out of bit 3 of the result; cleared otherwise. This flag is used in binary-coded decimal (BCD) arithmetic.\n\n\nZF (bit 6)\nZero flag. Set if the result is zero; cleared otherwise.\n\n\nSF (bit 7)\nSign flag. Set equal to the most-significant bit of the result, which is the sign bit of a signed integer. (0 indicates a positive value and 1 indicates a negative value.)\n\n\nOF (bit 11)\nOverflow flag. Set if the integer result is too large a positive number or too small a negative number (excluding the sign-bit) to fit in the destination operand; cleared otherwise. This flag indicates an over flow condition for signed-integer (two’s complement) arithmetic.\n\n\n\nOf these status flags, only the CF flag can be modified directly, using the STC, CLC, and CMC instructions. Also the bit instructions (BT, BTS, BTR, and BTC) copy a specified bit into the CF flag.\n\n\n\n\nAddress Space\n\nThe memory that the processor addresses on its bus is called physical memory.\nPhysical memory is organized as a sequence of 8-bit bytes. Each memory byte is assigned a unique address, called a physical address. In IA-32 architecture, physical addresses range from zero to a maximum of 232−1 (or 236−1 when Physical Address Extension PAE is enabled).\nx86 memory has three major memory models, which are:\n\nReal-mode flat model\nReal-mode segmented model\n32-bit protected-mode flat model\n64-bit long mode (will be discussed later in this course)\n\n\n\nReal-Mode Flat Model\n\nIn real-mode flat model, a program and all the data it works on must exist within a single 64KB block of memory.\nThe segment registers are all set to point to the beginning of the 64KB block of memory (The OS sets them when it loads and runs the program).\n\n\n\nReal-Mode Segmented Model\n\nYour program can still see 1MB of memory available to the CPU in real mode. However, the 20-bit address is constructed by combining the 16-bit segment address with 16-bit offset address.\n\n\n\n32-Bit Protected Mode Flat Model\n\nIn 32-bit protected mode, a program can address a linear address space of up to 4GB.\n\nEach address is 32-bit quantity including the EIP.\nThe segment registers are still exist, but controlled by the operating system. You, as programmer, neither read nor change them directly. The segment registers define where your 4GB memory space exists in physical or virtual memory.",
    "crumbs": [
      "Lectures",
      "Lecture 1: Basic Concepts"
    ]
  },
  {
    "objectID": "lectures/lec01.html#assembly-language",
    "href": "lectures/lec01.html#assembly-language",
    "title": "Lecture 1: Basic Concepts",
    "section": "Assembly Language",
    "text": "Assembly Language\n\nWhat is Assembly Language\n\nAssembly Language is the oldest programming language, bears the closest resemblance to native machine language. Hence, assembly language is a low-level programming language.\nAssembly language for x86 (the focus of this course) means programming on microprocessors compatible with Intel and AMD processors running under Windows, Linux, Unix, etc.\n\n\n\nMachine Language\n\nA CPU can only execute machine instructions. These instructions are bit strings. The following is a short program written in machine language for the IBM PC:\n\n\n\nMachine Instruction\nDescription\n\n\n\n\n10100001 00000000 00000000\nMove content of memory word 0 to AX\n\n\n00000101 00000100 00000000\nAdd 4 to AX\n\n\n10100011 00000000 00000000\nMove content of AX to memory word 0\n\n\n\nA more convenient language to use is assembly language. It uses symbolic names to represent operations, registers, and/or memory location. If memory location 0 is symbolized by A, the preceding program can be expressed like this in assembly language:\nmov   ax, [A]   ; move content of A to AX\nadd   ax, 4     ; add 4 to the content of AX\nmov   [A], ax   ; move content of AX to A\n\n\n\nAssembly Language Compared to High-Level Language\nThe following assignment statement (C/C++):\nint y = (x + 10) * 3;\ncan be translated to Assembly language as follows:\nmov   eax, [x]    ; move content of x to EAX register\nadd   eax, 10     ; Add 10 to EAX\nmov   ebx, 3      ; Let EBX = 3\nimul  ebx         ; perform EAX = EAX * EBX\nmov   [y], eax    ; store the result into Y\n\n\nIs Assembly Language Portable?\n\nA language whose source programs can be compiled and run on a wide variety of computer systems is said to be portable.\n\nJava is portable, compiled programs run nearly on any computer\nC++ is portable, can compile and run on any computer if standard library is used\n\nAssembly is NOT portable, because it is designed for a specific processor family and operating system.\n\n\n\nWhy Learning Assembly Language\n\nEfficiency in terms of size and time, because assembly language is so close to machine language\nWriting system programs (Operating system, Embedded programming, device driver, etc)\n\n\n\nThe Assembler\n\nUnfortunately, there is no standardization for x86 assembly language like other high-level languages, such as C and C++\nThe assembly language mainly depends on\n\nthe instruction set (ISA) of a microprocessor, and\na utility program called assembler.\n\n\n\n\nAn assembler: is a utility program that converts source code programs from assembly language into machine language (known as object source file).\nThere are many different assemblers out there for x86 architecture:\n\nMASM (Microsoft Macro Assembler)\nNASM (Netwide Assembler)\nTASM (Turbo Assembler)\nGAS (GNU Assembler)\n… and many more\n\nAll x86 assemblers use radically different assembly language\n\nThey agree on the instruction set (Like MOV, ADD, SUB, etc)\nThey differ on how the registers are used and how the operands are addressed.\n\nThis course will consider NASM assembler.\n\n\nNASM Assembler\n\nThe Netwide Assembler, NASM, is an IA-32 and Intel 64 assembler designed for portability and modularity\nNASM is a free cross-platform x86 assembler which supports all common x86 operating systems: Windows, Linux, MacOS X, Unix, etc.\nNASM provides a simple syntax that closely resembles Intel’s assembly language while offering compatibility with a variety of output formats, such as ELF, COFF, and Mach-O.\n\n\n\n\nProgramming Tools That You Need\n\nTo develop an assembly program, you need\n\nan assembler, which we are going to use NASM\nan editor; there are several choices\n\nVisual Studio Code\nNotepad++\nVIM under Linux\n\nA Linker: is a utility program that combines individual object files created by an assembler into a single executable program.\n(Optionally) a debugger, in case you need to debug your code.\n\n\n\nBuilding Process\n\n\n\nObject File Format\n\nCompilers and assemblers create object files containing the generated machine code and data for a source file. Linkers combine multiple object files into one binary file (known as image file or executable file). Loaders take image files and load them into memory (in order to be executed).\n\n\n\n\n\n\n\nWhat goes into object file?\n\n\n\n\nHeader information,\nRelocation table,\nSymbols,\nDebugging information, and\nof course, Machine code\n\n\n\n\nThere are many object file formats. Some you should know about include:\n\nCOFF, primary for UNIX\nWin32 and Win64, primary for Windows OS\nELF and ELF64, primary for Linux\nMacho32 and Macho64, primary for MacOS X",
    "crumbs": [
      "Lectures",
      "Lecture 1: Basic Concepts"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "C404: Assembly Language",
    "section": "",
    "text": "Course summary\nThis course covers the organization and behavior of real computer systems at the assembly-language level. Topics include the mapping of statements and constructs in a high-level language onto sequences of machine instructions, as well as the internal representation of simple data types and structures. Numerical computation and subroutines are examined.\n\n\nCourse Goals\nYou will gain the following knowledge in topics related to assembly language:\n\nIntel and AMD processor architecture and programming.\nDescribe von Neumann architecture and how its components interact.\nReal-address mode and protected mode programming.\nAssembly language directives, macros, operators, and program structure.\nDemonstrate how fundamental high-level programming constructs are implemented at the machine-language level.\nUnderstand the Assembly Language’s procedures, parameter passing and stack operations.\nProgramming methodology, showing how to use assembly language to create system-level software tools and application programs.\nDiagnosing and debuggin assembly language programs.\n\n\n\nTextbooks\n\n\n\n\n\n\nAssembly Language for x86\n\n\n\n\n\nAssembly Language for x86 Processors\nby Kip Irvine\nPearson 2019, 8th Edition\n\n\n\n\n\nLab Resources\nIt is quite important to try all examples in the lecture notes. You have two options:\n\nUse online compilers (Quick and easy):\n\nOneCompiler.com\n\nSee Lab(1)\n\n\n\nGrading\n\n\n\nActivity\nWeight\n\n\n\n\nLabs\n40%\n\n\nFinal Exam\n60%\n\n\n\n\n\nTentative Schedule\n\n\n\nWeek #\nTopic\nKip\nAssignment\n\n\n\n\n\nWeek 1\nBasic Concepts\nCh.1-2\nLab(1)",
    "crumbs": [
      "Home"
    ]
  }
]